{"ast":null,"code":"import { convertValue as $35a22f14a1f04b11$export$61a490a80c552550, createPlaceholderDate as $35a22f14a1f04b11$export$66aa2b09de4b1ea5, getFormatOptions as $35a22f14a1f04b11$export$7e319ea407e63bc0, getValidationResult as $35a22f14a1f04b11$export$f18627323ab57ac0, useDefaultProps as $35a22f14a1f04b11$export$2440da353cedad43 } from \"./utils.mjs\";\nimport { getPlaceholder as $3e3ed55ab2966714$export$d3f5c5e0a5023fa0 } from \"./placeholders.mjs\";\nimport { DateFormatter as $g03ag$DateFormatter, isEqualCalendar as $g03ag$isEqualCalendar, toCalendar as $g03ag$toCalendar, GregorianCalendar as $g03ag$GregorianCalendar, getMinimumMonthInYear as $g03ag$getMinimumMonthInYear, getMinimumDayInMonth as $g03ag$getMinimumDayInMonth } from \"@internationalized/date\";\nimport { useFormValidationState as $g03ag$useFormValidationState } from \"@react-stately/form\";\nimport { useControlledState as $g03ag$useControlledState } from \"@react-stately/utils\";\nimport { useMemo as $g03ag$useMemo, useState as $g03ag$useState, useRef as $g03ag$useRef, useEffect as $g03ag$useEffect } from \"react\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nconst $3c0fc76039f1c516$var$EDITABLE_SEGMENTS = {\n  year: true,\n  month: true,\n  day: true,\n  hour: true,\n  minute: true,\n  second: true,\n  dayPeriod: true,\n  era: true\n};\nconst $3c0fc76039f1c516$var$PAGE_STEP = {\n  year: 5,\n  month: 2,\n  day: 7,\n  hour: 2,\n  minute: 15,\n  second: 15\n};\nconst $3c0fc76039f1c516$var$TYPE_MAPPING = {\n  // Node seems to convert everything to lowercase...\n  dayperiod: 'dayPeriod',\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat/formatToParts#named_years\n  relatedYear: 'year',\n  yearName: 'literal',\n  unknown: 'literal'\n};\nfunction $3c0fc76039f1c516$export$60e84778edff6d26(props) {\n  let {\n    locale: locale,\n    createCalendar: createCalendar,\n    hideTimeZone: hideTimeZone,\n    isDisabled = false,\n    isReadOnly = false,\n    isRequired = false,\n    minValue: minValue,\n    maxValue: maxValue,\n    isDateUnavailable: isDateUnavailable\n  } = props;\n  let v = props.value || props.defaultValue || props.placeholderValue || null;\n  let [granularity, defaultTimeZone] = (0, $35a22f14a1f04b11$export$2440da353cedad43)(v, props.granularity);\n  let timeZone = defaultTimeZone || 'UTC';\n  // props.granularity must actually exist in the value if one is provided.\n  if (v && !(granularity in v)) throw new Error('Invalid granularity ' + granularity + ' for value ' + v.toString());\n  let defaultFormatter = (0, $g03ag$useMemo)(() => new (0, $g03ag$DateFormatter)(locale), [locale]);\n  let calendar = (0, $g03ag$useMemo)(() => createCalendar(defaultFormatter.resolvedOptions().calendar), [createCalendar, defaultFormatter]);\n  var _props_defaultValue;\n  let [value, setDate] = (0, $g03ag$useControlledState)(props.value, (_props_defaultValue = props.defaultValue) !== null && _props_defaultValue !== void 0 ? _props_defaultValue : null, props.onChange);\n  let [initialValue] = (0, $g03ag$useState)(value);\n  let calendarValue = (0, $g03ag$useMemo)(() => {\n    var _convertValue;\n    return (_convertValue = (0, $35a22f14a1f04b11$export$61a490a80c552550)(value, calendar)) !== null && _convertValue !== void 0 ? _convertValue : null;\n  }, [value, calendar]);\n  // We keep track of the placeholder date separately in state so that onChange is not called\n  // until all segments are set. If the value === null (not undefined), then assume the component\n  // is controlled, so use the placeholder as the value until all segments are entered so it doesn't\n  // change from uncontrolled to controlled and emit a warning.\n  let [placeholderDate, setPlaceholderDate] = (0, $g03ag$useState)(() => (0, $35a22f14a1f04b11$export$66aa2b09de4b1ea5)(props.placeholderValue, granularity, calendar, defaultTimeZone));\n  let val = calendarValue || placeholderDate;\n  let showEra = calendar.identifier === 'gregory' && val.era === 'BC';\n  let formatOpts = (0, $g03ag$useMemo)(() => {\n    var _props_maxGranularity;\n    return {\n      granularity: granularity,\n      maxGranularity: (_props_maxGranularity = props.maxGranularity) !== null && _props_maxGranularity !== void 0 ? _props_maxGranularity : 'year',\n      timeZone: defaultTimeZone,\n      hideTimeZone: hideTimeZone,\n      hourCycle: props.hourCycle,\n      showEra: showEra,\n      shouldForceLeadingZeros: props.shouldForceLeadingZeros\n    };\n  }, [props.maxGranularity, granularity, props.hourCycle, props.shouldForceLeadingZeros, defaultTimeZone, hideTimeZone, showEra]);\n  let opts = (0, $g03ag$useMemo)(() => (0, $35a22f14a1f04b11$export$7e319ea407e63bc0)({}, formatOpts), [formatOpts]);\n  let dateFormatter = (0, $g03ag$useMemo)(() => new (0, $g03ag$DateFormatter)(locale, opts), [locale, opts]);\n  let resolvedOptions = (0, $g03ag$useMemo)(() => dateFormatter.resolvedOptions(), [dateFormatter]);\n  // Determine how many editable segments there are for validation purposes.\n  // The result is cached for performance.\n  let allSegments = (0, $g03ag$useMemo)(() => dateFormatter.formatToParts(new Date()).filter(seg => $3c0fc76039f1c516$var$EDITABLE_SEGMENTS[seg.type]).reduce((p, seg) => (p[$3c0fc76039f1c516$var$TYPE_MAPPING[seg.type] || seg.type] = true, p), {}), [dateFormatter]);\n  let [validSegments, setValidSegments] = (0, $g03ag$useState)(() => props.value || props.defaultValue ? {\n    ...allSegments\n  } : {});\n  let clearedSegment = (0, $g03ag$useRef)(null);\n  // Reset placeholder when calendar changes\n  let lastCalendar = (0, $g03ag$useRef)(calendar);\n  (0, $g03ag$useEffect)(() => {\n    if (!(0, $g03ag$isEqualCalendar)(calendar, lastCalendar.current)) {\n      lastCalendar.current = calendar;\n      setPlaceholderDate(placeholder => Object.keys(validSegments).length > 0 ? (0, $g03ag$toCalendar)(placeholder, calendar) : (0, $35a22f14a1f04b11$export$66aa2b09de4b1ea5)(props.placeholderValue, granularity, calendar, defaultTimeZone));\n    }\n  }, [calendar, granularity, validSegments, defaultTimeZone, props.placeholderValue]);\n  // If there is a value prop, and some segments were previously placeholders, mark them all as valid.\n  if (value && Object.keys(validSegments).length < Object.keys(allSegments).length) {\n    validSegments = {\n      ...allSegments\n    };\n    setValidSegments(validSegments);\n  }\n  // If the value is set to null and all segments are valid, reset the placeholder.\n  if (value == null && Object.keys(validSegments).length === Object.keys(allSegments).length) {\n    validSegments = {};\n    setValidSegments(validSegments);\n    setPlaceholderDate((0, $35a22f14a1f04b11$export$66aa2b09de4b1ea5)(props.placeholderValue, granularity, calendar, defaultTimeZone));\n  }\n  // If all segments are valid, use the date from state, otherwise use the placeholder date.\n  let displayValue = calendarValue && Object.keys(validSegments).length >= Object.keys(allSegments).length ? calendarValue : placeholderDate;\n  let setValue = newValue => {\n    if (props.isDisabled || props.isReadOnly) return;\n    let validKeys = Object.keys(validSegments);\n    let allKeys = Object.keys(allSegments);\n    // if all the segments are completed or a timefield with everything but am/pm set the time, also ignore when am/pm cleared\n    if (newValue == null) {\n      setDate(null);\n      setPlaceholderDate((0, $35a22f14a1f04b11$export$66aa2b09de4b1ea5)(props.placeholderValue, granularity, calendar, defaultTimeZone));\n      setValidSegments({});\n    } else if (validKeys.length === 0 && clearedSegment.current == null || validKeys.length >= allKeys.length || validKeys.length === allKeys.length - 1 && allSegments.dayPeriod && !validSegments.dayPeriod && clearedSegment.current !== 'dayPeriod') {\n      // If the field was empty (no valid segments) or all segments are completed, commit the new value.\n      // When committing from an empty state, mark every segment as valid so value is committed.\n      if (validKeys.length === 0) {\n        validSegments = {\n          ...allSegments\n        };\n        setValidSegments(validSegments);\n      }\n      // The display calendar should not have any effect on the emitted value.\n      // Emit dates in the same calendar as the original value, if any, otherwise gregorian.\n      newValue = (0, $g03ag$toCalendar)(newValue, (v === null || v === void 0 ? void 0 : v.calendar) || new (0, $g03ag$GregorianCalendar)());\n      setDate(newValue);\n    } else setPlaceholderDate(newValue);\n    clearedSegment.current = null;\n  };\n  let dateValue = (0, $g03ag$useMemo)(() => displayValue.toDate(timeZone), [displayValue, timeZone]);\n  let segments = (0, $g03ag$useMemo)(() => $3c0fc76039f1c516$var$processSegments(dateValue, validSegments, dateFormatter, resolvedOptions, displayValue, calendar, locale, granularity), [dateValue, validSegments, dateFormatter, resolvedOptions, displayValue, calendar, locale, granularity]);\n  // When the era field appears, mark it valid if the year field is already valid.\n  // If the era field disappears, remove it from the valid segments.\n  if (allSegments.era && validSegments.year && !validSegments.era) {\n    validSegments.era = true;\n    setValidSegments({\n      ...validSegments\n    });\n  } else if (!allSegments.era && validSegments.era) {\n    delete validSegments.era;\n    setValidSegments({\n      ...validSegments\n    });\n  }\n  let markValid = part => {\n    validSegments[part] = true;\n    if (part === 'year' && allSegments.era) validSegments.era = true;\n    setValidSegments({\n      ...validSegments\n    });\n  };\n  let adjustSegment = (type, amount) => {\n    if (!validSegments[type]) {\n      markValid(type);\n      let validKeys = Object.keys(validSegments);\n      let allKeys = Object.keys(allSegments);\n      if (validKeys.length >= allKeys.length || validKeys.length === allKeys.length - 1 && allSegments.dayPeriod && !validSegments.dayPeriod) setValue(displayValue);\n    } else setValue($3c0fc76039f1c516$var$addSegment(displayValue, type, amount, resolvedOptions));\n  };\n  let builtinValidation = (0, $g03ag$useMemo)(() => (0, $35a22f14a1f04b11$export$f18627323ab57ac0)(value, minValue, maxValue, isDateUnavailable, formatOpts), [value, minValue, maxValue, isDateUnavailable, formatOpts]);\n  let validation = (0, $g03ag$useFormValidationState)({\n    ...props,\n    value: value,\n    builtinValidation: builtinValidation\n  });\n  let isValueInvalid = validation.displayValidation.isInvalid;\n  let validationState = props.validationState || (isValueInvalid ? 'invalid' : null);\n  var _props_defaultValue1, _props_maxGranularity;\n  return {\n    ...validation,\n    value: calendarValue,\n    defaultValue: (_props_defaultValue1 = props.defaultValue) !== null && _props_defaultValue1 !== void 0 ? _props_defaultValue1 : initialValue,\n    dateValue: dateValue,\n    calendar: calendar,\n    setValue: setValue,\n    segments: segments,\n    dateFormatter: dateFormatter,\n    validationState: validationState,\n    isInvalid: isValueInvalid,\n    granularity: granularity,\n    maxGranularity: (_props_maxGranularity = props.maxGranularity) !== null && _props_maxGranularity !== void 0 ? _props_maxGranularity : 'year',\n    isDisabled: isDisabled,\n    isReadOnly: isReadOnly,\n    isRequired: isRequired,\n    increment(part) {\n      adjustSegment(part, 1);\n    },\n    decrement(part) {\n      adjustSegment(part, -1);\n    },\n    incrementPage(part) {\n      adjustSegment(part, $3c0fc76039f1c516$var$PAGE_STEP[part] || 1);\n    },\n    decrementPage(part) {\n      adjustSegment(part, -($3c0fc76039f1c516$var$PAGE_STEP[part] || 1));\n    },\n    setSegment(part, v) {\n      markValid(part);\n      setValue($3c0fc76039f1c516$var$setSegment(displayValue, part, v, resolvedOptions));\n    },\n    confirmPlaceholder() {\n      if (props.isDisabled || props.isReadOnly) return;\n      // Confirm the placeholder if only the day period is not filled in.\n      let validKeys = Object.keys(validSegments);\n      let allKeys = Object.keys(allSegments);\n      if (validKeys.length === allKeys.length - 1 && allSegments.dayPeriod && !validSegments.dayPeriod) {\n        validSegments = {\n          ...allSegments\n        };\n        setValidSegments(validSegments);\n        setValue(displayValue.copy());\n      }\n    },\n    clearSegment(part) {\n      delete validSegments[part];\n      clearedSegment.current = part;\n      setValidSegments({\n        ...validSegments\n      });\n      let placeholder = (0, $35a22f14a1f04b11$export$66aa2b09de4b1ea5)(props.placeholderValue, granularity, calendar, defaultTimeZone);\n      let value = displayValue;\n      // Reset day period to default without changing the hour.\n      if (part === 'dayPeriod' && 'hour' in displayValue && 'hour' in placeholder) {\n        let isPM = displayValue.hour >= 12;\n        let shouldBePM = placeholder.hour >= 12;\n        if (isPM && !shouldBePM) value = displayValue.set({\n          hour: displayValue.hour - 12\n        });else if (!isPM && shouldBePM) value = displayValue.set({\n          hour: displayValue.hour + 12\n        });\n      } else if (part === 'hour' && 'hour' in displayValue && displayValue.hour >= 12 && validSegments.dayPeriod) value = displayValue.set({\n        hour: placeholder['hour'] + 12\n      });else if (part in displayValue) value = displayValue.set({\n        [part]: placeholder[part]\n      });\n      setDate(null);\n      setValue(value);\n    },\n    formatValue(fieldOptions) {\n      if (!calendarValue) return '';\n      let formatOptions = (0, $35a22f14a1f04b11$export$7e319ea407e63bc0)(fieldOptions, formatOpts);\n      let formatter = new (0, $g03ag$DateFormatter)(locale, formatOptions);\n      return formatter.format(dateValue);\n    },\n    getDateFormatter(locale, formatOptions) {\n      let newOptions = {\n        ...formatOpts,\n        ...formatOptions\n      };\n      let newFormatOptions = (0, $35a22f14a1f04b11$export$7e319ea407e63bc0)({}, newOptions);\n      return new (0, $g03ag$DateFormatter)(locale, newFormatOptions);\n    }\n  };\n}\nfunction $3c0fc76039f1c516$var$processSegments(dateValue, validSegments, dateFormatter, resolvedOptions, displayValue, calendar, locale, granularity) {\n  let timeValue = ['hour', 'minute', 'second'];\n  let segments = dateFormatter.formatToParts(dateValue);\n  let processedSegments = [];\n  for (let segment of segments) {\n    let type = $3c0fc76039f1c516$var$TYPE_MAPPING[segment.type] || segment.type;\n    let isEditable = $3c0fc76039f1c516$var$EDITABLE_SEGMENTS[type];\n    if (type === 'era' && calendar.getEras().length === 1) isEditable = false;\n    let isPlaceholder = $3c0fc76039f1c516$var$EDITABLE_SEGMENTS[type] && !validSegments[type];\n    let placeholder = $3c0fc76039f1c516$var$EDITABLE_SEGMENTS[type] ? (0, $3e3ed55ab2966714$export$d3f5c5e0a5023fa0)(type, segment.value, locale) : null;\n    let dateSegment = {\n      type: type,\n      text: isPlaceholder ? placeholder : segment.value,\n      ...$3c0fc76039f1c516$var$getSegmentLimits(displayValue, type, resolvedOptions),\n      isPlaceholder: isPlaceholder,\n      placeholder: placeholder,\n      isEditable: isEditable\n    };\n    // There is an issue in RTL languages where time fields render (minute:hour) instead of (hour:minute).\n    // To force an LTR direction on the time field since, we wrap the time segments in LRI (left-to-right) isolate unicode. See https://www.w3.org/International/questions/qa-bidi-unicode-controls.\n    // These unicode characters will be added to the array of processed segments as literals and will mark the start and end of the embedded direction change.\n    if (type === 'hour') {\n      // This marks the start of the embedded direction change.\n      processedSegments.push({\n        type: 'literal',\n        text: '\\u2066',\n        ...$3c0fc76039f1c516$var$getSegmentLimits(displayValue, 'literal', resolvedOptions),\n        isPlaceholder: false,\n        placeholder: '',\n        isEditable: false\n      });\n      processedSegments.push(dateSegment);\n      // This marks the end of the embedded direction change in the case that the granularity it set to \"hour\".\n      if (type === granularity) processedSegments.push({\n        type: 'literal',\n        text: '\\u2069',\n        ...$3c0fc76039f1c516$var$getSegmentLimits(displayValue, 'literal', resolvedOptions),\n        isPlaceholder: false,\n        placeholder: '',\n        isEditable: false\n      });\n    } else if (timeValue.includes(type) && type === granularity) {\n      processedSegments.push(dateSegment);\n      // This marks the end of the embedded direction change.\n      processedSegments.push({\n        type: 'literal',\n        text: '\\u2069',\n        ...$3c0fc76039f1c516$var$getSegmentLimits(displayValue, 'literal', resolvedOptions),\n        isPlaceholder: false,\n        placeholder: '',\n        isEditable: false\n      });\n    } else\n      // We only want to \"wrap\" the unicode around segments that are hour, minute, or second. If they aren't, just process as normal.\n      processedSegments.push(dateSegment);\n  }\n  return processedSegments;\n}\nfunction $3c0fc76039f1c516$var$getSegmentLimits(date, type, options) {\n  switch (type) {\n    case 'era':\n      {\n        let eras = date.calendar.getEras();\n        return {\n          value: eras.indexOf(date.era),\n          minValue: 0,\n          maxValue: eras.length - 1\n        };\n      }\n    case 'year':\n      return {\n        value: date.year,\n        minValue: 1,\n        maxValue: date.calendar.getYearsInEra(date)\n      };\n    case 'month':\n      return {\n        value: date.month,\n        minValue: (0, $g03ag$getMinimumMonthInYear)(date),\n        maxValue: date.calendar.getMonthsInYear(date)\n      };\n    case 'day':\n      return {\n        value: date.day,\n        minValue: (0, $g03ag$getMinimumDayInMonth)(date),\n        maxValue: date.calendar.getDaysInMonth(date)\n      };\n  }\n  if ('hour' in date) switch (type) {\n    case 'dayPeriod':\n      return {\n        value: date.hour >= 12 ? 12 : 0,\n        minValue: 0,\n        maxValue: 12\n      };\n    case 'hour':\n      if (options.hour12) {\n        let isPM = date.hour >= 12;\n        return {\n          value: date.hour,\n          minValue: isPM ? 12 : 0,\n          maxValue: isPM ? 23 : 11\n        };\n      }\n      return {\n        value: date.hour,\n        minValue: 0,\n        maxValue: 23\n      };\n    case 'minute':\n      return {\n        value: date.minute,\n        minValue: 0,\n        maxValue: 59\n      };\n    case 'second':\n      return {\n        value: date.second,\n        minValue: 0,\n        maxValue: 59\n      };\n  }\n  return {};\n}\nfunction $3c0fc76039f1c516$var$addSegment(value, part, amount, options) {\n  switch (part) {\n    case 'era':\n    case 'year':\n    case 'month':\n    case 'day':\n      return value.cycle(part, amount, {\n        round: part === 'year'\n      });\n  }\n  if ('hour' in value) switch (part) {\n    case 'dayPeriod':\n      {\n        let hours = value.hour;\n        let isPM = hours >= 12;\n        return value.set({\n          hour: isPM ? hours - 12 : hours + 12\n        });\n      }\n    case 'hour':\n    case 'minute':\n    case 'second':\n      return value.cycle(part, amount, {\n        round: part !== 'hour',\n        hourCycle: options.hour12 ? 12 : 24\n      });\n  }\n  throw new Error('Unknown segment: ' + part);\n}\nfunction $3c0fc76039f1c516$var$setSegment(value, part, segmentValue, options) {\n  switch (part) {\n    case 'day':\n    case 'month':\n    case 'year':\n    case 'era':\n      return value.set({\n        [part]: segmentValue\n      });\n  }\n  if ('hour' in value && typeof segmentValue === 'number') switch (part) {\n    case 'dayPeriod':\n      {\n        let hours = value.hour;\n        let wasPM = hours >= 12;\n        let isPM = segmentValue >= 12;\n        if (isPM === wasPM) return value;\n        return value.set({\n          hour: wasPM ? hours - 12 : hours + 12\n        });\n      }\n    case 'hour':\n      // In 12 hour time, ensure that AM/PM does not change\n      if (options.hour12) {\n        let hours = value.hour;\n        let wasPM = hours >= 12;\n        if (!wasPM && segmentValue === 12) segmentValue = 0;\n        if (wasPM && segmentValue < 12) segmentValue += 12;\n      }\n    // fallthrough\n    case 'minute':\n    case 'second':\n      return value.set({\n        [part]: segmentValue\n      });\n  }\n  throw new Error('Unknown segment: ' + part);\n}\nexport { $3c0fc76039f1c516$export$60e84778edff6d26 as useDateFieldState };","map":{"version":3,"names":["$3c0fc76039f1c516$var$EDITABLE_SEGMENTS","year","month","day","hour","minute","second","dayPeriod","era","$3c0fc76039f1c516$var$PAGE_STEP","$3c0fc76039f1c516$var$TYPE_MAPPING","dayperiod","relatedYear","yearName","unknown","$3c0fc76039f1c516$export$60e84778edff6d26","props","locale","createCalendar","hideTimeZone","isDisabled","isReadOnly","isRequired","minValue","maxValue","isDateUnavailable","v","value","defaultValue","placeholderValue","granularity","defaultTimeZone","$35a22f14a1f04b11$export$2440da353cedad43","timeZone","Error","toString","defaultFormatter","$g03ag$useMemo","$g03ag$DateFormatter","calendar","resolvedOptions","_props_defaultValue","setDate","$g03ag$useControlledState","onChange","initialValue","$g03ag$useState","calendarValue","_convertValue","$35a22f14a1f04b11$export$61a490a80c552550","placeholderDate","setPlaceholderDate","$35a22f14a1f04b11$export$66aa2b09de4b1ea5","val","showEra","identifier","formatOpts","_props_maxGranularity","maxGranularity","hourCycle","shouldForceLeadingZeros","opts","$35a22f14a1f04b11$export$7e319ea407e63bc0","dateFormatter","allSegments","formatToParts","Date","filter","seg","type","reduce","p","validSegments","setValidSegments","clearedSegment","$g03ag$useRef","lastCalendar","$g03ag$useEffect","$g03ag$isEqualCalendar","current","placeholder","Object","keys","length","$g03ag$toCalendar","displayValue","setValue","newValue","validKeys","allKeys","$g03ag$GregorianCalendar","dateValue","toDate","segments","$3c0fc76039f1c516$var$processSegments","markValid","part","adjustSegment","amount","$3c0fc76039f1c516$var$addSegment","builtinValidation","$35a22f14a1f04b11$export$f18627323ab57ac0","validation","$g03ag$useFormValidationState","isValueInvalid","displayValidation","isInvalid","validationState","_props_defaultValue1","increment","decrement","incrementPage","decrementPage","setSegment","$3c0fc76039f1c516$var$setSegment","confirmPlaceholder","copy","clearSegment","isPM","shouldBePM","set","formatValue","fieldOptions","formatOptions","formatter","format","getDateFormatter","newOptions","newFormatOptions","timeValue","processedSegments","segment","isEditable","getEras","isPlaceholder","$3e3ed55ab2966714$export$d3f5c5e0a5023fa0","dateSegment","text","$3c0fc76039f1c516$var$getSegmentLimits","push","includes","date","options","eras","indexOf","getYearsInEra","$g03ag$getMinimumMonthInYear","getMonthsInYear","$g03ag$getMinimumDayInMonth","getDaysInMonth","hour12","cycle","round","hours","segmentValue","wasPM"],"sources":["C:\\Users\\Aluno\\Documents\\GitHub\\--Arcano_Store--\\arcanostore\\node_modules\\@react-stately\\datepicker\\dist\\packages\\@react-stately\\datepicker\\src\\useDateFieldState.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Calendar, CalendarIdentifier, DateFormatter, getMinimumDayInMonth, getMinimumMonthInYear, GregorianCalendar, isEqualCalendar, toCalendar} from '@internationalized/date';\nimport {convertValue, createPlaceholderDate, FieldOptions, FormatterOptions, getFormatOptions, getValidationResult, useDefaultProps} from './utils';\nimport {DatePickerProps, DateValue, Granularity, MappedDateValue} from '@react-types/datepicker';\nimport {FormValidationState, useFormValidationState} from '@react-stately/form';\nimport {getPlaceholder} from './placeholders';\nimport {useControlledState} from '@react-stately/utils';\nimport {useEffect, useMemo, useRef, useState} from 'react';\nimport {ValidationState} from '@react-types/shared';\n\nexport type SegmentType = 'era' | 'year' | 'month' | 'day' |  'hour' | 'minute' | 'second' | 'dayPeriod' | 'literal' | 'timeZoneName';\nexport interface DateSegment {\n  /** The type of segment. */\n  type: SegmentType,\n  /** The formatted text for the segment. */\n  text: string,\n  /** The numeric value for the segment, if applicable. */\n  value?: number,\n  /** The minimum numeric value for the segment, if applicable. */\n  minValue?: number,\n  /** The maximum numeric value for the segment, if applicable. */\n  maxValue?: number,\n  /** Whether the value is a placeholder. */\n  isPlaceholder: boolean,\n  /** A placeholder string for the segment. */\n  placeholder: string,\n  /** Whether the segment is editable. */\n  isEditable: boolean\n}\n\nexport interface DateFieldState extends FormValidationState {\n  /** The current field value. */\n  value: DateValue | null,\n  /** The default field value. */\n  defaultValue: DateValue | null,\n  /** The current value, converted to a native JavaScript `Date` object.  */\n  dateValue: Date,\n  /** The calendar system currently in use. */\n  calendar: Calendar,\n  /** Sets the field's value. */\n  setValue(value: DateValue | null): void,\n  /** A list of segments for the current value. */\n  segments: DateSegment[],\n  /** A date formatter configured for the current locale and format. */\n  dateFormatter: DateFormatter,\n  /**\n   * The current validation state of the date field, based on the `validationState`, `minValue`, and `maxValue` props.\n   * @deprecated Use `isInvalid` instead.\n   */\n  validationState: ValidationState | null,\n  /** Whether the date field is invalid, based on the `isInvalid`, `minValue`, and `maxValue` props. */\n  isInvalid: boolean,\n  /** The granularity for the field, based on the `granularity` prop and current value. */\n  granularity: Granularity,\n  /** The maximum date or time unit that is displayed in the field. */\n  maxGranularity: 'year' | 'month' | Granularity,\n  /** Whether the field is disabled. */\n  isDisabled: boolean,\n  /** Whether the field is read only. */\n  isReadOnly: boolean,\n  /** Whether the field is required. */\n  isRequired: boolean,\n  /** Increments the given segment. Upon reaching the minimum or maximum value, the value wraps around to the opposite limit. */\n  increment(type: SegmentType): void,\n  /** Decrements the given segment. Upon reaching the minimum or maximum value, the value wraps around to the opposite limit. */\n  decrement(type: SegmentType): void,\n  /**\n   * Increments the given segment by a larger amount, rounding it to the nearest increment.\n   * The amount to increment by depends on the field, for example 15 minutes, 7 days, and 5 years.\n   * Upon reaching the minimum or maximum value, the value wraps around to the opposite limit.\n   */\n  incrementPage(type: SegmentType): void,\n  /**\n   * Decrements the given segment by a larger amount, rounding it to the nearest increment.\n   * The amount to decrement by depends on the field, for example 15 minutes, 7 days, and 5 years.\n   * Upon reaching the minimum or maximum value, the value wraps around to the opposite limit.\n   */\n  decrementPage(type: SegmentType): void,\n  /** Sets the value of the given segment. */\n  setSegment(type: 'era', value: string): void,\n  setSegment(type: SegmentType, value: number): void,\n  /** Updates the remaining unfilled segments with the placeholder value. */\n  confirmPlaceholder(): void,\n  /** Clears the value of the given segment, reverting it to the placeholder. */\n  clearSegment(type: SegmentType): void,\n  /** Formats the current date value using the given options. */\n  formatValue(fieldOptions: FieldOptions): string,\n  /** Gets a formatter based on state's props. */\n  getDateFormatter(locale: string, formatOptions: FormatterOptions): DateFormatter\n}\n\nconst EDITABLE_SEGMENTS = {\n  year: true,\n  month: true,\n  day: true,\n  hour: true,\n  minute: true,\n  second: true,\n  dayPeriod: true,\n  era: true\n};\n\nconst PAGE_STEP = {\n  year: 5,\n  month: 2,\n  day: 7,\n  hour: 2,\n  minute: 15,\n  second: 15\n};\n\nconst TYPE_MAPPING = {\n  // Node seems to convert everything to lowercase...\n  dayperiod: 'dayPeriod',\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat/formatToParts#named_years\n  relatedYear: 'year',\n  yearName: 'literal', // not editable\n  unknown: 'literal'\n};\n\nexport interface DateFieldStateOptions<T extends DateValue = DateValue> extends DatePickerProps<T> {\n  /**\n   * The maximum unit to display in the date field.\n   * @default 'year'\n   */\n  maxGranularity?: 'year' | 'month' | Granularity,\n  /** The locale to display and edit the value according to. */\n  locale: string,\n  /**\n   * A function that creates a [Calendar](../internationalized/date/Calendar.html)\n   * object for a given calendar identifier. Such a function may be imported from the\n   * `@internationalized/date` package, or manually implemented to include support for\n   * only certain calendars.\n   */\n  createCalendar: (name: CalendarIdentifier) => Calendar\n}\n\n/**\n * Provides state management for a date field component.\n * A date field allows users to enter and edit date and time values using a keyboard.\n * Each part of a date value is displayed in an individually editable segment.\n */\nexport function useDateFieldState<T extends DateValue = DateValue>(props: DateFieldStateOptions<T>): DateFieldState {\n  let {\n    locale,\n    createCalendar,\n    hideTimeZone,\n    isDisabled = false,\n    isReadOnly = false,\n    isRequired = false,\n    minValue,\n    maxValue,\n    isDateUnavailable\n  } = props;\n\n  let v: DateValue | null = props.value || props.defaultValue || props.placeholderValue || null;\n  let [granularity, defaultTimeZone] = useDefaultProps(v, props.granularity);\n  let timeZone = defaultTimeZone || 'UTC';\n\n  // props.granularity must actually exist in the value if one is provided.\n  if (v && !(granularity in v)) {\n    throw new Error('Invalid granularity ' + granularity + ' for value ' + v.toString());\n  }\n\n  let defaultFormatter = useMemo(() => new DateFormatter(locale), [locale]);\n  let calendar = useMemo(() => createCalendar(defaultFormatter.resolvedOptions().calendar as CalendarIdentifier), [createCalendar, defaultFormatter]);\n\n  let [value, setDate] = useControlledState<DateValue | null, MappedDateValue<T> | null>(\n    props.value,\n    props.defaultValue ?? null,\n    props.onChange\n  );\n\n  let [initialValue] = useState(value);\n  let calendarValue = useMemo(() => convertValue(value, calendar) ?? null, [value, calendar]);\n\n  // We keep track of the placeholder date separately in state so that onChange is not called\n  // until all segments are set. If the value === null (not undefined), then assume the component\n  // is controlled, so use the placeholder as the value until all segments are entered so it doesn't\n  // change from uncontrolled to controlled and emit a warning.\n  let [placeholderDate, setPlaceholderDate] = useState(\n    () => createPlaceholderDate(props.placeholderValue, granularity, calendar, defaultTimeZone)\n  );\n\n  let val = calendarValue || placeholderDate;\n  let showEra = calendar.identifier === 'gregory' && val.era === 'BC';\n  let formatOpts = useMemo(() => ({\n    granularity,\n    maxGranularity: props.maxGranularity ?? 'year',\n    timeZone: defaultTimeZone,\n    hideTimeZone,\n    hourCycle: props.hourCycle,\n    showEra,\n    shouldForceLeadingZeros: props.shouldForceLeadingZeros\n  }), [props.maxGranularity, granularity, props.hourCycle, props.shouldForceLeadingZeros, defaultTimeZone, hideTimeZone, showEra]);\n  let opts = useMemo(() => getFormatOptions({}, formatOpts), [formatOpts]);\n\n  let dateFormatter = useMemo(() => new DateFormatter(locale, opts), [locale, opts]);\n  let resolvedOptions = useMemo(() => dateFormatter.resolvedOptions(), [dateFormatter]);\n\n  // Determine how many editable segments there are for validation purposes.\n  // The result is cached for performance.\n  let allSegments: Partial<typeof EDITABLE_SEGMENTS> = useMemo(() =>\n    dateFormatter.formatToParts(new Date())\n      .filter(seg => EDITABLE_SEGMENTS[seg.type])\n      .reduce((p, seg) => (p[TYPE_MAPPING[seg.type] || seg.type] = true, p), {})\n  , [dateFormatter]);\n\n  let [validSegments, setValidSegments] = useState<Partial<typeof EDITABLE_SEGMENTS>>(\n    () => props.value || props.defaultValue ? {...allSegments} : {}\n  );\n\n  let clearedSegment = useRef<string | null>(null);\n\n  // Reset placeholder when calendar changes\n  let lastCalendar = useRef(calendar);\n  useEffect(() => {\n    if (!isEqualCalendar(calendar, lastCalendar.current)) {\n      lastCalendar.current = calendar;\n      setPlaceholderDate(placeholder =>\n        Object.keys(validSegments).length > 0\n          ? toCalendar(placeholder, calendar)\n          : createPlaceholderDate(props.placeholderValue, granularity, calendar, defaultTimeZone)\n      );\n    }\n  }, [calendar, granularity, validSegments, defaultTimeZone, props.placeholderValue]);\n\n  // If there is a value prop, and some segments were previously placeholders, mark them all as valid.\n  if (value && Object.keys(validSegments).length < Object.keys(allSegments).length) {\n    validSegments = {...allSegments};\n    setValidSegments(validSegments);\n  }\n\n  // If the value is set to null and all segments are valid, reset the placeholder.\n  if (value == null && Object.keys(validSegments).length === Object.keys(allSegments).length) {\n    validSegments = {};\n    setValidSegments(validSegments);\n    setPlaceholderDate(createPlaceholderDate(props.placeholderValue, granularity, calendar, defaultTimeZone));\n  }\n\n  // If all segments are valid, use the date from state, otherwise use the placeholder date.\n  let displayValue = calendarValue && Object.keys(validSegments).length >= Object.keys(allSegments).length ? calendarValue : placeholderDate;\n  let setValue = (newValue: DateValue) => {\n    if (props.isDisabled || props.isReadOnly) {\n      return;\n    }\n    let validKeys = Object.keys(validSegments);\n    let allKeys = Object.keys(allSegments);\n\n    // if all the segments are completed or a timefield with everything but am/pm set the time, also ignore when am/pm cleared\n    if (newValue == null) {\n      setDate(null);\n      setPlaceholderDate(createPlaceholderDate(props.placeholderValue, granularity, calendar, defaultTimeZone));\n      setValidSegments({});\n    } else if (\n      (validKeys.length === 0 && clearedSegment.current == null) ||\n      validKeys.length >= allKeys.length ||\n      (validKeys.length === allKeys.length - 1 && allSegments.dayPeriod && !validSegments.dayPeriod && clearedSegment.current !== 'dayPeriod')\n    ) {\n      // If the field was empty (no valid segments) or all segments are completed, commit the new value.\n      // When committing from an empty state, mark every segment as valid so value is committed.\n      if (validKeys.length === 0) {\n        validSegments = {...allSegments};\n        setValidSegments(validSegments);\n      }\n\n      // The display calendar should not have any effect on the emitted value.\n      // Emit dates in the same calendar as the original value, if any, otherwise gregorian.\n      newValue = toCalendar(newValue, v?.calendar || new GregorianCalendar());\n      setDate(newValue);\n    } else {\n      setPlaceholderDate(newValue);\n    }\n    clearedSegment.current = null;\n  };\n\n  let dateValue = useMemo(() => displayValue.toDate(timeZone), [displayValue, timeZone]);\n  let segments = useMemo(() =>\n    processSegments(dateValue, validSegments, dateFormatter, resolvedOptions, displayValue, calendar, locale, granularity),\n    [dateValue, validSegments, dateFormatter, resolvedOptions, displayValue, calendar, locale, granularity]);\n\n  // When the era field appears, mark it valid if the year field is already valid.\n  // If the era field disappears, remove it from the valid segments.\n  if (allSegments.era && validSegments.year && !validSegments.era) {\n    validSegments.era = true;\n    setValidSegments({...validSegments});\n  } else if (!allSegments.era && validSegments.era) {\n    delete validSegments.era;\n    setValidSegments({...validSegments});\n  }\n\n  let markValid = (part: Intl.DateTimeFormatPartTypes) => {\n    validSegments[part] = true;\n    if (part === 'year' && allSegments.era) {\n      validSegments.era = true;\n    }\n    setValidSegments({...validSegments});\n  };\n\n  let adjustSegment = (type: Intl.DateTimeFormatPartTypes, amount: number) => {\n    if (!validSegments[type]) {\n      markValid(type);\n      let validKeys = Object.keys(validSegments);\n      let allKeys = Object.keys(allSegments);\n      if (validKeys.length >= allKeys.length || (validKeys.length === allKeys.length - 1 && allSegments.dayPeriod && !validSegments.dayPeriod)) {\n        setValue(displayValue);\n      }\n    } else {\n      setValue(addSegment(displayValue, type, amount, resolvedOptions));\n    }\n  };\n\n  let builtinValidation = useMemo(() => getValidationResult(\n    value,\n    minValue,\n    maxValue,\n    isDateUnavailable,\n    formatOpts\n  ), [value, minValue, maxValue, isDateUnavailable, formatOpts]);\n\n  let validation = useFormValidationState({\n    ...props,\n    value: value as MappedDateValue<T> | null,\n    builtinValidation\n  });\n\n  let isValueInvalid = validation.displayValidation.isInvalid;\n  let validationState: ValidationState | null = props.validationState || (isValueInvalid ? 'invalid' : null);\n\n  return {\n    ...validation,\n    value: calendarValue,\n    defaultValue: props.defaultValue ?? initialValue,\n    dateValue,\n    calendar,\n    setValue,\n    segments,\n    dateFormatter,\n    validationState,\n    isInvalid: isValueInvalid,\n    granularity,\n    maxGranularity: props.maxGranularity ?? 'year',\n    isDisabled,\n    isReadOnly,\n    isRequired,\n    increment(part) {\n      adjustSegment(part, 1);\n    },\n    decrement(part) {\n      adjustSegment(part, -1);\n    },\n    incrementPage(part) {\n      adjustSegment(part, PAGE_STEP[part] || 1);\n    },\n    decrementPage(part) {\n      adjustSegment(part, -(PAGE_STEP[part] || 1));\n    },\n    setSegment(part, v: string | number) {\n      markValid(part);\n      setValue(setSegment(displayValue, part, v, resolvedOptions));\n    },\n    confirmPlaceholder() {\n      if (props.isDisabled || props.isReadOnly) {\n        return;\n      }\n\n      // Confirm the placeholder if only the day period is not filled in.\n      let validKeys = Object.keys(validSegments);\n      let allKeys = Object.keys(allSegments);\n      if (validKeys.length === allKeys.length - 1 && allSegments.dayPeriod && !validSegments.dayPeriod) {\n        validSegments = {...allSegments};\n        setValidSegments(validSegments);\n        setValue(displayValue.copy());\n      }\n    },\n    clearSegment(part) {\n      delete validSegments[part];\n      clearedSegment.current = part;\n      setValidSegments({...validSegments});\n\n      let placeholder = createPlaceholderDate(props.placeholderValue, granularity, calendar, defaultTimeZone);\n      let value = displayValue;\n\n      // Reset day period to default without changing the hour.\n      if (part === 'dayPeriod' && 'hour' in displayValue && 'hour' in placeholder) {\n        let isPM = displayValue.hour >= 12;\n        let shouldBePM = placeholder.hour >= 12;\n        if (isPM && !shouldBePM) {\n          value = displayValue.set({hour: displayValue.hour - 12});\n        } else if (!isPM && shouldBePM) {\n          value = displayValue.set({hour: displayValue.hour + 12});\n        }\n      } else if (part === 'hour' && 'hour' in displayValue && displayValue.hour >= 12 && validSegments.dayPeriod) {\n        value = displayValue.set({hour: placeholder['hour'] + 12});\n      } else if (part in displayValue) {\n        value = displayValue.set({[part]: placeholder[part]});\n      }\n\n      setDate(null);\n      setValue(value);\n    },\n    formatValue(fieldOptions: FieldOptions) {\n      if (!calendarValue) {\n        return '';\n      }\n\n      let formatOptions = getFormatOptions(fieldOptions, formatOpts);\n      let formatter = new DateFormatter(locale, formatOptions);\n      return formatter.format(dateValue);\n    },\n    getDateFormatter(locale, formatOptions: FormatterOptions) {\n      let newOptions = {...formatOpts, ...formatOptions};\n      let newFormatOptions = getFormatOptions({}, newOptions);\n      return new DateFormatter(locale, newFormatOptions);\n    }\n  };\n}\n\nfunction processSegments(dateValue, validSegments, dateFormatter, resolvedOptions, displayValue, calendar, locale, granularity) : DateSegment[] {\n  let timeValue = ['hour', 'minute', 'second'];\n  let segments = dateFormatter.formatToParts(dateValue);\n  let processedSegments: DateSegment[] = [];\n  for (let segment of segments) {\n    let type = TYPE_MAPPING[segment.type] || segment.type;\n    let isEditable = EDITABLE_SEGMENTS[type];\n    if (type === 'era' && calendar.getEras().length === 1) {\n      isEditable = false;\n    }\n\n    let isPlaceholder = EDITABLE_SEGMENTS[type] && !validSegments[type];\n    let placeholder = EDITABLE_SEGMENTS[type] ? getPlaceholder(type, segment.value, locale) : null;\n\n    let dateSegment = {\n      type,\n      text: isPlaceholder ? placeholder : segment.value,\n      ...getSegmentLimits(displayValue, type, resolvedOptions),\n      isPlaceholder,\n      placeholder,\n      isEditable\n    } as DateSegment;\n\n    // There is an issue in RTL languages where time fields render (minute:hour) instead of (hour:minute).\n    // To force an LTR direction on the time field since, we wrap the time segments in LRI (left-to-right) isolate unicode. See https://www.w3.org/International/questions/qa-bidi-unicode-controls.\n    // These unicode characters will be added to the array of processed segments as literals and will mark the start and end of the embedded direction change.\n    if (type === 'hour') {\n      // This marks the start of the embedded direction change.\n      processedSegments.push({\n        type: 'literal',\n        text: '\\u2066',\n        ...getSegmentLimits(displayValue, 'literal', resolvedOptions),\n        isPlaceholder: false,\n        placeholder: '',\n        isEditable: false\n      });\n      processedSegments.push(dateSegment);\n      // This marks the end of the embedded direction change in the case that the granularity it set to \"hour\".\n      if (type === granularity) {\n        processedSegments.push({\n          type: 'literal',\n          text: '\\u2069',\n          ...getSegmentLimits(displayValue, 'literal', resolvedOptions),\n          isPlaceholder: false,\n          placeholder: '',\n          isEditable: false\n        });\n      }\n    } else if (timeValue.includes(type) && type === granularity) {\n      processedSegments.push(dateSegment);\n      // This marks the end of the embedded direction change.\n      processedSegments.push({\n        type: 'literal',\n        text: '\\u2069',\n        ...getSegmentLimits(displayValue, 'literal', resolvedOptions),\n        isPlaceholder: false,\n        placeholder: '',\n        isEditable: false\n      });\n    } else {\n      // We only want to \"wrap\" the unicode around segments that are hour, minute, or second. If they aren't, just process as normal.\n      processedSegments.push(dateSegment);\n    }\n  }\n\n  return processedSegments;\n}\n\nfunction getSegmentLimits(date: DateValue, type: string, options: Intl.ResolvedDateTimeFormatOptions) {\n  switch (type) {\n    case 'era': {\n      let eras = date.calendar.getEras();\n      return {\n        value: eras.indexOf(date.era),\n        minValue: 0,\n        maxValue: eras.length - 1\n      };\n    }\n    case 'year':\n      return {\n        value: date.year,\n        minValue: 1,\n        maxValue: date.calendar.getYearsInEra(date)\n      };\n    case 'month':\n      return {\n        value: date.month,\n        minValue: getMinimumMonthInYear(date),\n        maxValue: date.calendar.getMonthsInYear(date)\n      };\n    case 'day':\n      return {\n        value: date.day,\n        minValue: getMinimumDayInMonth(date),\n        maxValue: date.calendar.getDaysInMonth(date)\n      };\n  }\n\n  if ('hour' in date) {\n    switch (type) {\n      case 'dayPeriod':\n        return {\n          value: date.hour >= 12 ? 12 : 0,\n          minValue: 0,\n          maxValue: 12\n        };\n      case 'hour':\n        if (options.hour12) {\n          let isPM = date.hour >= 12;\n          return {\n            value: date.hour,\n            minValue: isPM ? 12 : 0,\n            maxValue: isPM ? 23 : 11\n          };\n        }\n\n        return {\n          value: date.hour,\n          minValue: 0,\n          maxValue: 23\n        };\n      case 'minute':\n        return {\n          value: date.minute,\n          minValue: 0,\n          maxValue: 59\n        };\n      case 'second':\n        return {\n          value: date.second,\n          minValue: 0,\n          maxValue: 59\n        };\n    }\n  }\n\n  return {};\n}\n\nfunction addSegment(value: DateValue, part: string, amount: number, options: Intl.ResolvedDateTimeFormatOptions) {\n  switch (part) {\n    case 'era':\n    case 'year':\n    case 'month':\n    case 'day':\n      return value.cycle(part, amount, {round: part === 'year'});\n  }\n\n  if ('hour' in value) {\n    switch (part) {\n      case 'dayPeriod': {\n        let hours = value.hour;\n        let isPM = hours >= 12;\n        return value.set({hour: isPM ? hours - 12 : hours + 12});\n      }\n      case 'hour':\n      case 'minute':\n      case 'second':\n        return value.cycle(part, amount, {\n          round: part !== 'hour',\n          hourCycle: options.hour12 ? 12 : 24\n        });\n    }\n  }\n\n  throw new Error('Unknown segment: ' + part);\n}\n\nfunction setSegment(value: DateValue, part: string, segmentValue: number | string, options: Intl.ResolvedDateTimeFormatOptions) {\n  switch (part) {\n    case 'day':\n    case 'month':\n    case 'year':\n    case 'era':\n      return value.set({[part]: segmentValue});\n  }\n\n  if ('hour' in value && typeof segmentValue === 'number') {\n    switch (part) {\n      case 'dayPeriod': {\n        let hours = value.hour;\n        let wasPM = hours >= 12;\n        let isPM = segmentValue >= 12;\n        if (isPM === wasPM) {\n          return value;\n        }\n        return value.set({hour: wasPM ? hours - 12 : hours + 12});\n      }\n      case 'hour':\n        // In 12 hour time, ensure that AM/PM does not change\n        if (options.hour12) {\n          let hours = value.hour;\n          let wasPM = hours >= 12;\n          if (!wasPM && segmentValue === 12) {\n            segmentValue = 0;\n          }\n          if (wasPM && segmentValue < 12) {\n            segmentValue += 12;\n          }\n        }\n        // fallthrough\n      case 'minute':\n      case 'second':\n        return value.set({[part]: segmentValue});\n    }\n  }\n\n  throw new Error('Unknown segment: ' + part);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}