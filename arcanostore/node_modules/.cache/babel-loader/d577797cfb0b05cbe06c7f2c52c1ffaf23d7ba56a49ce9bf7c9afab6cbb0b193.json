{"ast":null,"code":"import { useLayoutEffect as $7mMvr$useLayoutEffect, isIOS as $7mMvr$isIOS, chain as $7mMvr$chain, getScrollParent as $7mMvr$getScrollParent } from \"@react-aria/utils\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nconst $49c51c25361d4cd2$var$visualViewport = typeof document !== 'undefined' && window.visualViewport;\n// HTML input types that do not cause the software keyboard to appear.\nconst $49c51c25361d4cd2$var$nonTextInputTypes = new Set(['checkbox', 'radio', 'range', 'color', 'file', 'image', 'button', 'submit', 'reset']);\n// The number of active usePreventScroll calls. Used to determine whether to revert back to the original page style/scroll position\nlet $49c51c25361d4cd2$var$preventScrollCount = 0;\nlet $49c51c25361d4cd2$var$restore;\nfunction $49c51c25361d4cd2$export$ee0f7cc6afcd1c18(options = {}) {\n  let {\n    isDisabled: isDisabled\n  } = options;\n  (0, $7mMvr$useLayoutEffect)(() => {\n    if (isDisabled) return;\n    $49c51c25361d4cd2$var$preventScrollCount++;\n    if ($49c51c25361d4cd2$var$preventScrollCount === 1) {\n      if ((0, $7mMvr$isIOS)()) $49c51c25361d4cd2$var$restore = $49c51c25361d4cd2$var$preventScrollMobileSafari();else $49c51c25361d4cd2$var$restore = $49c51c25361d4cd2$var$preventScrollStandard();\n    }\n    return () => {\n      $49c51c25361d4cd2$var$preventScrollCount--;\n      if ($49c51c25361d4cd2$var$preventScrollCount === 0) $49c51c25361d4cd2$var$restore();\n    };\n  }, [isDisabled]);\n}\n// For most browsers, all we need to do is set `overflow: hidden` on the root element, and\n// add some padding to prevent the page from shifting when the scrollbar is hidden.\nfunction $49c51c25361d4cd2$var$preventScrollStandard() {\n  let scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;\n  return (0, $7mMvr$chain)(scrollbarWidth > 0 && (\n  // Use scrollbar-gutter when supported because it also works for fixed positioned elements.\n  'scrollbarGutter' in document.documentElement.style ? $49c51c25361d4cd2$var$setStyle(document.documentElement, 'scrollbarGutter', 'stable') : $49c51c25361d4cd2$var$setStyle(document.documentElement, 'paddingRight', `${scrollbarWidth}px`)), $49c51c25361d4cd2$var$setStyle(document.documentElement, 'overflow', 'hidden'));\n}\n// Mobile Safari is a whole different beast. Even with overflow: hidden,\n// it still scrolls the page in many situations:\n//\n// 1. When the bottom toolbar and address bar are collapsed, page scrolling is always allowed.\n// 2. When the keyboard is visible, the viewport does not resize. Instead, the keyboard covers part of\n//    it, so it becomes scrollable.\n// 3. When tapping on an input, the page always scrolls so that the input is centered in the visual viewport.\n//    This may cause even fixed position elements to scroll off the screen.\n// 4. When using the next/previous buttons in the keyboard to navigate between inputs, the whole page always\n//    scrolls, even if the input is inside a nested scrollable element that could be scrolled instead.\n//\n// In order to work around these cases, and prevent scrolling without jankiness, we do a few things:\n//\n// 1. Prevent default on `touchmove` events that are not in a scrollable element. This prevents touch scrolling\n//    on the window.\n// 2. Set `overscroll-behavior: contain` on nested scrollable regions so they do not scroll the page when at\n//    the top or bottom. Work around a bug where this does not work when the element does not actually overflow\n//    by preventing default in a `touchmove` event.\n// 3. Prevent default on `touchend` events on input elements and handle focusing the element ourselves.\n// 4. When focusing an input, apply a transform to trick Safari into thinking the input is at the top\n//    of the page, which prevents it from scrolling the page. After the input is focused, scroll the element\n//    into view ourselves, without scrolling the whole page.\n// 5. Offset the body by the scroll position using a negative margin and scroll to the top. This should appear the\n//    same visually, but makes the actual scroll position always zero. This is required to make all of the\n//    above work or Safari will still try to scroll the page when focusing an input.\n// 6. As a last resort, handle window scroll events, and scroll back to the top. This can happen when attempting\n//    to navigate to an input with the next/previous buttons that's outside a modal.\nfunction $49c51c25361d4cd2$var$preventScrollMobileSafari() {\n  let scrollable;\n  let restoreScrollableStyles;\n  let onTouchStart = e => {\n    // Store the nearest scrollable parent element from the element that the user touched.\n    scrollable = (0, $7mMvr$getScrollParent)(e.target, true);\n    if (scrollable === document.documentElement && scrollable === document.body) return;\n    // Prevent scrolling up when at the top and scrolling down when at the bottom\n    // of a nested scrollable area, otherwise mobile Safari will start scrolling\n    // the window instead.\n    if (scrollable instanceof HTMLElement && window.getComputedStyle(scrollable).overscrollBehavior === 'auto') restoreScrollableStyles = $49c51c25361d4cd2$var$setStyle(scrollable, 'overscrollBehavior', 'contain');\n  };\n  let onTouchMove = e => {\n    // Prevent scrolling the window.\n    if (!scrollable || scrollable === document.documentElement || scrollable === document.body) {\n      e.preventDefault();\n      return;\n    }\n    // overscroll-behavior should prevent scroll chaining, but currently does not\n    // if the element doesn't actually overflow. https://bugs.webkit.org/show_bug.cgi?id=243452\n    // This checks that both the width and height do not overflow, otherwise we might\n    // block horizontal scrolling too. In that case, adding `touch-action: pan-x` to\n    // the element will prevent vertical page scrolling. We can't add that automatically\n    // because it must be set before the touchstart event.\n    if (scrollable.scrollHeight === scrollable.clientHeight && scrollable.scrollWidth === scrollable.clientWidth) e.preventDefault();\n  };\n  let onTouchEnd = () => {\n    if (restoreScrollableStyles) restoreScrollableStyles();\n  };\n  let onFocus = e => {\n    let target = e.target;\n    if ($49c51c25361d4cd2$var$willOpenKeyboard(target)) {\n      setupStyles();\n      // Apply a transform to trick Safari into thinking the input is at the top of the page\n      // so it doesn't try to scroll it into view.\n      target.style.transform = 'translateY(-2000px)';\n      requestAnimationFrame(() => {\n        target.style.transform = '';\n        // This will have prevented the browser from scrolling the focused element into view,\n        // so we need to do this ourselves in a way that doesn't cause the whole page to scroll.\n        if ($49c51c25361d4cd2$var$visualViewport) {\n          if ($49c51c25361d4cd2$var$visualViewport.height < window.innerHeight)\n            // If the keyboard is already visible, do this after one additional frame\n            // to wait for the transform to be removed.\n            requestAnimationFrame(() => {\n              $49c51c25361d4cd2$var$scrollIntoView(target);\n            });else\n            // Otherwise, wait for the visual viewport to resize before scrolling so we can\n            // measure the correct position to scroll to.\n            $49c51c25361d4cd2$var$visualViewport.addEventListener('resize', () => $49c51c25361d4cd2$var$scrollIntoView(target), {\n              once: true\n            });\n        }\n      });\n    }\n  };\n  let restoreStyles = null;\n  let setupStyles = () => {\n    if (restoreStyles) return;\n    let onWindowScroll = () => {\n      // Last resort. If the window scrolled, scroll it back to the top.\n      // It should always be at the top because the body will have a negative margin (see below).\n      window.scrollTo(0, 0);\n    };\n    // Record the original scroll position so we can restore it.\n    // Then apply a negative margin to the body to offset it by the scroll position. This will\n    // enable us to scroll the window to the top, which is required for the rest of this to work.\n    let scrollX = window.pageXOffset;\n    let scrollY = window.pageYOffset;\n    restoreStyles = (0, $7mMvr$chain)($49c51c25361d4cd2$var$addEvent(window, 'scroll', onWindowScroll), $49c51c25361d4cd2$var$setStyle(document.documentElement, 'paddingRight', `${window.innerWidth - document.documentElement.clientWidth}px`), $49c51c25361d4cd2$var$setStyle(document.documentElement, 'overflow', 'hidden'), $49c51c25361d4cd2$var$setStyle(document.body, 'marginTop', `-${scrollY}px`), () => {\n      window.scrollTo(scrollX, scrollY);\n    });\n    // Scroll to the top. The negative margin on the body will make this appear the same.\n    window.scrollTo(0, 0);\n  };\n  let removeEvents = (0, $7mMvr$chain)($49c51c25361d4cd2$var$addEvent(document, 'touchstart', onTouchStart, {\n    passive: false,\n    capture: true\n  }), $49c51c25361d4cd2$var$addEvent(document, 'touchmove', onTouchMove, {\n    passive: false,\n    capture: true\n  }), $49c51c25361d4cd2$var$addEvent(document, 'touchend', onTouchEnd, {\n    passive: false,\n    capture: true\n  }), $49c51c25361d4cd2$var$addEvent(document, 'focus', onFocus, true));\n  return () => {\n    // Restore styles and scroll the page back to where it was.\n    restoreScrollableStyles === null || restoreScrollableStyles === void 0 ? void 0 : restoreScrollableStyles();\n    restoreStyles === null || restoreStyles === void 0 ? void 0 : restoreStyles();\n    removeEvents();\n  };\n}\n// Sets a CSS property on an element, and returns a function to revert it to the previous value.\nfunction $49c51c25361d4cd2$var$setStyle(element, style, value) {\n  let cur = element.style[style];\n  element.style[style] = value;\n  return () => {\n    element.style[style] = cur;\n  };\n}\n// Adds an event listener to an element, and returns a function to remove it.\nfunction $49c51c25361d4cd2$var$addEvent(target, event, handler, options) {\n  // internal function, so it's ok to ignore the difficult to fix type error\n  // @ts-ignore\n  target.addEventListener(event, handler, options);\n  return () => {\n    // @ts-ignore\n    target.removeEventListener(event, handler, options);\n  };\n}\nfunction $49c51c25361d4cd2$var$scrollIntoView(target) {\n  let root = document.scrollingElement || document.documentElement;\n  let nextTarget = target;\n  while (nextTarget && nextTarget !== root) {\n    // Find the parent scrollable element and adjust the scroll position if the target is not already in view.\n    let scrollable = (0, $7mMvr$getScrollParent)(nextTarget);\n    if (scrollable !== document.documentElement && scrollable !== document.body && scrollable !== nextTarget) {\n      let scrollableTop = scrollable.getBoundingClientRect().top;\n      let targetTop = nextTarget.getBoundingClientRect().top;\n      if (targetTop > scrollableTop + nextTarget.clientHeight) scrollable.scrollTop += targetTop - scrollableTop;\n    }\n    nextTarget = scrollable.parentElement;\n  }\n}\nfunction $49c51c25361d4cd2$var$willOpenKeyboard(target) {\n  return target instanceof HTMLInputElement && !$49c51c25361d4cd2$var$nonTextInputTypes.has(target.type) || target instanceof HTMLTextAreaElement || target instanceof HTMLElement && target.isContentEditable;\n}\nexport { $49c51c25361d4cd2$export$ee0f7cc6afcd1c18 as usePreventScroll };","map":{"version":3,"names":["$49c51c25361d4cd2$var$visualViewport","document","window","visualViewport","$49c51c25361d4cd2$var$nonTextInputTypes","Set","$49c51c25361d4cd2$var$preventScrollCount","$49c51c25361d4cd2$var$restore","$49c51c25361d4cd2$export$ee0f7cc6afcd1c18","options","isDisabled","$7mMvr$useLayoutEffect","$7mMvr$isIOS","$49c51c25361d4cd2$var$preventScrollMobileSafari","$49c51c25361d4cd2$var$preventScrollStandard","scrollbarWidth","innerWidth","documentElement","clientWidth","$7mMvr$chain","style","$49c51c25361d4cd2$var$setStyle","scrollable","restoreScrollableStyles","onTouchStart","e","$7mMvr$getScrollParent","target","body","HTMLElement","getComputedStyle","overscrollBehavior","onTouchMove","preventDefault","scrollHeight","clientHeight","scrollWidth","onTouchEnd","onFocus","$49c51c25361d4cd2$var$willOpenKeyboard","setupStyles","transform","requestAnimationFrame","height","innerHeight","$49c51c25361d4cd2$var$scrollIntoView","addEventListener","once","restoreStyles","onWindowScroll","scrollTo","scrollX","pageXOffset","scrollY","pageYOffset","$49c51c25361d4cd2$var$addEvent","removeEvents","passive","capture","element","value","cur","event","handler","removeEventListener","root","scrollingElement","nextTarget","scrollableTop","getBoundingClientRect","top","targetTop","scrollTop","parentElement","HTMLInputElement","has","type","HTMLTextAreaElement","isContentEditable"],"sources":["C:\\Users\\Aluno\\Documents\\GitHub\\--Arcano_Store--\\arcanostore\\node_modules\\@heroui\\use-aria-modal-overlay\\node_modules\\@react-aria\\overlays\\dist\\packages\\@react-aria\\overlays\\src\\usePreventScroll.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {chain, getScrollParent, isIOS, useLayoutEffect} from '@react-aria/utils';\n\ninterface PreventScrollOptions {\n  /** Whether the scroll lock is disabled. */\n  isDisabled?: boolean\n}\n\nconst visualViewport = typeof document !== 'undefined' && window.visualViewport;\n\n// HTML input types that do not cause the software keyboard to appear.\nconst nonTextInputTypes = new Set([\n  'checkbox',\n  'radio',\n  'range',\n  'color',\n  'file',\n  'image',\n  'button',\n  'submit',\n  'reset'\n]);\n\n// The number of active usePreventScroll calls. Used to determine whether to revert back to the original page style/scroll position\nlet preventScrollCount = 0;\nlet restore;\n\n/**\n * Prevents scrolling on the document body on mount, and\n * restores it on unmount. Also ensures that content does not\n * shift due to the scrollbars disappearing.\n */\nexport function usePreventScroll(options: PreventScrollOptions = {}): void {\n  let {isDisabled} = options;\n\n  useLayoutEffect(() => {\n    if (isDisabled) {\n      return;\n    }\n\n    preventScrollCount++;\n    if (preventScrollCount === 1) {\n      if (isIOS()) {\n        restore = preventScrollMobileSafari();\n      } else {\n        restore = preventScrollStandard();\n      }\n    }\n\n    return () => {\n      preventScrollCount--;\n      if (preventScrollCount === 0) {\n        restore();\n      }\n    };\n  }, [isDisabled]);\n}\n\n// For most browsers, all we need to do is set `overflow: hidden` on the root element, and\n// add some padding to prevent the page from shifting when the scrollbar is hidden.\nfunction preventScrollStandard() {\n  let scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;\n  return chain(\n    scrollbarWidth > 0 &&\n      // Use scrollbar-gutter when supported because it also works for fixed positioned elements.\n      ('scrollbarGutter' in document.documentElement.style\n        ? setStyle(document.documentElement, 'scrollbarGutter', 'stable')\n        : setStyle(document.documentElement, 'paddingRight', `${scrollbarWidth}px`)),\n    setStyle(document.documentElement, 'overflow', 'hidden')\n  );\n}\n\n// Mobile Safari is a whole different beast. Even with overflow: hidden,\n// it still scrolls the page in many situations:\n//\n// 1. When the bottom toolbar and address bar are collapsed, page scrolling is always allowed.\n// 2. When the keyboard is visible, the viewport does not resize. Instead, the keyboard covers part of\n//    it, so it becomes scrollable.\n// 3. When tapping on an input, the page always scrolls so that the input is centered in the visual viewport.\n//    This may cause even fixed position elements to scroll off the screen.\n// 4. When using the next/previous buttons in the keyboard to navigate between inputs, the whole page always\n//    scrolls, even if the input is inside a nested scrollable element that could be scrolled instead.\n//\n// In order to work around these cases, and prevent scrolling without jankiness, we do a few things:\n//\n// 1. Prevent default on `touchmove` events that are not in a scrollable element. This prevents touch scrolling\n//    on the window.\n// 2. Set `overscroll-behavior: contain` on nested scrollable regions so they do not scroll the page when at\n//    the top or bottom. Work around a bug where this does not work when the element does not actually overflow\n//    by preventing default in a `touchmove` event.\n// 3. Prevent default on `touchend` events on input elements and handle focusing the element ourselves.\n// 4. When focusing an input, apply a transform to trick Safari into thinking the input is at the top\n//    of the page, which prevents it from scrolling the page. After the input is focused, scroll the element\n//    into view ourselves, without scrolling the whole page.\n// 5. Offset the body by the scroll position using a negative margin and scroll to the top. This should appear the\n//    same visually, but makes the actual scroll position always zero. This is required to make all of the\n//    above work or Safari will still try to scroll the page when focusing an input.\n// 6. As a last resort, handle window scroll events, and scroll back to the top. This can happen when attempting\n//    to navigate to an input with the next/previous buttons that's outside a modal.\nfunction preventScrollMobileSafari() {\n  let scrollable: Element;\n  let restoreScrollableStyles;\n  let onTouchStart = (e: TouchEvent) => {\n    // Store the nearest scrollable parent element from the element that the user touched.\n    scrollable = getScrollParent(e.target as Element, true);\n    if (scrollable === document.documentElement && scrollable === document.body) {\n      return;\n    }\n\n    // Prevent scrolling up when at the top and scrolling down when at the bottom\n    // of a nested scrollable area, otherwise mobile Safari will start scrolling\n    // the window instead.\n    if (scrollable instanceof HTMLElement && window.getComputedStyle(scrollable).overscrollBehavior === 'auto') {\n      restoreScrollableStyles = setStyle(scrollable, 'overscrollBehavior', 'contain');\n    }\n  };\n\n  let onTouchMove = (e: TouchEvent) => {\n    // Prevent scrolling the window.\n    if (!scrollable || scrollable === document.documentElement || scrollable === document.body) {\n      e.preventDefault();\n      return;\n    }\n\n    // overscroll-behavior should prevent scroll chaining, but currently does not\n    // if the element doesn't actually overflow. https://bugs.webkit.org/show_bug.cgi?id=243452\n    // This checks that both the width and height do not overflow, otherwise we might\n    // block horizontal scrolling too. In that case, adding `touch-action: pan-x` to\n    // the element will prevent vertical page scrolling. We can't add that automatically\n    // because it must be set before the touchstart event.\n    if (scrollable.scrollHeight === scrollable.clientHeight && scrollable.scrollWidth === scrollable.clientWidth) {\n      e.preventDefault();\n    }\n  };\n\n  let onTouchEnd = () => {\n    if (restoreScrollableStyles) {\n      restoreScrollableStyles();\n    }\n  };\n\n  let onFocus = (e: FocusEvent) => {\n    let target = e.target as HTMLElement;\n    if (willOpenKeyboard(target)) {\n      setupStyles();\n\n      // Apply a transform to trick Safari into thinking the input is at the top of the page\n      // so it doesn't try to scroll it into view.\n      target.style.transform = 'translateY(-2000px)';\n      requestAnimationFrame(() => {\n        target.style.transform = '';\n\n        // This will have prevented the browser from scrolling the focused element into view,\n        // so we need to do this ourselves in a way that doesn't cause the whole page to scroll.\n        if (visualViewport) {\n          if (visualViewport.height < window.innerHeight) {\n            // If the keyboard is already visible, do this after one additional frame\n            // to wait for the transform to be removed.\n            requestAnimationFrame(() => {\n              scrollIntoView(target);\n            });\n          } else {\n            // Otherwise, wait for the visual viewport to resize before scrolling so we can\n            // measure the correct position to scroll to.\n            visualViewport.addEventListener('resize', () => scrollIntoView(target), {once: true});\n          }\n        }\n      });\n    }\n  };\n\n  let restoreStyles: null | (() => void) = null;\n  let setupStyles = () => {\n    if (restoreStyles) {\n      return;\n    }\n\n    let onWindowScroll = () => {\n      // Last resort. If the window scrolled, scroll it back to the top.\n      // It should always be at the top because the body will have a negative margin (see below).\n      window.scrollTo(0, 0);\n    };\n\n    // Record the original scroll position so we can restore it.\n    // Then apply a negative margin to the body to offset it by the scroll position. This will\n    // enable us to scroll the window to the top, which is required for the rest of this to work.\n    let scrollX = window.pageXOffset;\n    let scrollY = window.pageYOffset;\n\n    restoreStyles = chain(\n      addEvent(window, 'scroll', onWindowScroll),\n      setStyle(document.documentElement, 'paddingRight', `${window.innerWidth - document.documentElement.clientWidth}px`),\n      setStyle(document.documentElement, 'overflow', 'hidden'),\n      setStyle(document.body, 'marginTop', `-${scrollY}px`),\n      () => {\n        window.scrollTo(scrollX, scrollY);\n      }\n    );\n\n    // Scroll to the top. The negative margin on the body will make this appear the same.\n    window.scrollTo(0, 0);\n  };\n\n  let removeEvents = chain(\n    addEvent(document, 'touchstart', onTouchStart, {passive: false, capture: true}),\n    addEvent(document, 'touchmove', onTouchMove, {passive: false, capture: true}),\n    addEvent(document, 'touchend', onTouchEnd, {passive: false, capture: true}),\n    addEvent(document, 'focus', onFocus, true)\n  );\n\n  return () => {\n    // Restore styles and scroll the page back to where it was.\n    restoreScrollableStyles?.();\n    restoreStyles?.();\n    removeEvents();\n  };\n}\n\n// Sets a CSS property on an element, and returns a function to revert it to the previous value.\nfunction setStyle(element: HTMLElement, style: string, value: string) {\n  let cur = element.style[style];\n  element.style[style] = value;\n\n  return () => {\n    element.style[style] = cur;\n  };\n}\n\n// Adds an event listener to an element, and returns a function to remove it.\nfunction addEvent<K extends keyof GlobalEventHandlersEventMap>(\n  target: Document | Window,\n  event: K,\n  handler: (this: Document | Window, ev: GlobalEventHandlersEventMap[K]) => any,\n  options?: boolean | AddEventListenerOptions\n) {\n  // internal function, so it's ok to ignore the difficult to fix type error\n  // @ts-ignore\n  target.addEventListener(event, handler, options);\n  return () => {\n    // @ts-ignore\n    target.removeEventListener(event, handler, options);\n  };\n}\n\nfunction scrollIntoView(target: Element) {\n  let root = document.scrollingElement || document.documentElement;\n  let nextTarget: Element | null = target;\n  while (nextTarget && nextTarget !== root) {\n    // Find the parent scrollable element and adjust the scroll position if the target is not already in view.\n    let scrollable = getScrollParent(nextTarget);\n    if (scrollable !== document.documentElement && scrollable !== document.body && scrollable !== nextTarget) {\n      let scrollableTop = scrollable.getBoundingClientRect().top;\n      let targetTop = nextTarget.getBoundingClientRect().top;\n      if (targetTop > scrollableTop + nextTarget.clientHeight) {\n        scrollable.scrollTop += targetTop - scrollableTop;\n      }\n    }\n\n    nextTarget = scrollable.parentElement;\n  }\n}\n\nfunction willOpenKeyboard(target: Element) {\n  return (\n    (target instanceof HTMLInputElement && !nonTextInputTypes.has(target.type)) ||\n    target instanceof HTMLTextAreaElement ||\n    (target instanceof HTMLElement && target.isContentEditable)\n  );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}