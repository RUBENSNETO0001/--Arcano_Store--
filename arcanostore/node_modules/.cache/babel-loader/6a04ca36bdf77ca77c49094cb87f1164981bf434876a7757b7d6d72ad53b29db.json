{"ast":null,"code":"import { useLayoutEffect as $7mMvr$useLayoutEffect, isIOS as $7mMvr$isIOS, chain as $7mMvr$chain, isScrollable as $7mMvr$isScrollable, getScrollParent as $7mMvr$getScrollParent, willOpenKeyboard as $7mMvr$willOpenKeyboard } from \"@react-aria/utils\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nconst $49c51c25361d4cd2$var$visualViewport = typeof document !== 'undefined' && window.visualViewport;\n// The number of active usePreventScroll calls. Used to determine whether to revert back to the original page style/scroll position\nlet $49c51c25361d4cd2$var$preventScrollCount = 0;\nlet $49c51c25361d4cd2$var$restore;\nfunction $49c51c25361d4cd2$export$ee0f7cc6afcd1c18(options = {}) {\n  let {\n    isDisabled: isDisabled\n  } = options;\n  (0, $7mMvr$useLayoutEffect)(() => {\n    if (isDisabled) return;\n    $49c51c25361d4cd2$var$preventScrollCount++;\n    if ($49c51c25361d4cd2$var$preventScrollCount === 1) {\n      if ((0, $7mMvr$isIOS)()) $49c51c25361d4cd2$var$restore = $49c51c25361d4cd2$var$preventScrollMobileSafari();else $49c51c25361d4cd2$var$restore = $49c51c25361d4cd2$var$preventScrollStandard();\n    }\n    return () => {\n      $49c51c25361d4cd2$var$preventScrollCount--;\n      if ($49c51c25361d4cd2$var$preventScrollCount === 0) $49c51c25361d4cd2$var$restore();\n    };\n  }, [isDisabled]);\n}\n// For most browsers, all we need to do is set `overflow: hidden` on the root element, and\n// add some padding to prevent the page from shifting when the scrollbar is hidden.\nfunction $49c51c25361d4cd2$var$preventScrollStandard() {\n  let scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;\n  return (0, $7mMvr$chain)(scrollbarWidth > 0 && (\n  // Use scrollbar-gutter when supported because it also works for fixed positioned elements.\n  'scrollbarGutter' in document.documentElement.style ? $49c51c25361d4cd2$var$setStyle(document.documentElement, 'scrollbarGutter', 'stable') : $49c51c25361d4cd2$var$setStyle(document.documentElement, 'paddingRight', `${scrollbarWidth}px`)), $49c51c25361d4cd2$var$setStyle(document.documentElement, 'overflow', 'hidden'));\n}\n// Mobile Safari is a whole different beast. Even with overflow: hidden,\n// it still scrolls the page in many situations:\n//\n// 1. When the bottom toolbar and address bar are collapsed, page scrolling is always allowed.\n// 2. When the keyboard is visible, the viewport does not resize. Instead, the keyboard covers part of\n//    it, so it becomes scrollable.\n// 3. When tapping on an input, the page always scrolls so that the input is centered in the visual viewport.\n//    This may cause even fixed position elements to scroll off the screen.\n// 4. When using the next/previous buttons in the keyboard to navigate between inputs, the whole page always\n//    scrolls, even if the input is inside a nested scrollable element that could be scrolled instead.\n//\n// In order to work around these cases, and prevent scrolling without jankiness, we do a few things:\n//\n// 1. Prevent default on `touchmove` events that are not in a scrollable element. This prevents touch scrolling\n//    on the window.\n// 2. Set `overscroll-behavior: contain` on nested scrollable regions so they do not scroll the page when at\n//    the top or bottom. Work around a bug where this does not work when the element does not actually overflow\n//    by preventing default in a `touchmove` event. This is best effort: we can't prevent default when pinch\n//    zooming or when an element contains text selection, which may allow scrolling in some cases.\n// 3. Prevent default on `touchend` events on input elements and handle focusing the element ourselves.\n// 4. When focus moves to an input, create an off screen input and focus that temporarily. This prevents \n//    Safari from scrolling the page. After a small delay, focus the real input and scroll it into view\n//    ourselves, without scrolling the whole page.\nfunction $49c51c25361d4cd2$var$preventScrollMobileSafari() {\n  let scrollable;\n  let allowTouchMove = false;\n  let onTouchStart = e => {\n    // Store the nearest scrollable parent element from the element that the user touched.\n    let target = e.target;\n    scrollable = (0, $7mMvr$isScrollable)(target) ? target : (0, $7mMvr$getScrollParent)(target, true);\n    allowTouchMove = false;\n    // If the target is selected, don't preventDefault in touchmove to allow user to adjust selection.\n    let selection = target.ownerDocument.defaultView.getSelection();\n    if (selection && !selection.isCollapsed && selection.containsNode(target, true)) allowTouchMove = true;\n    // If this is a focused input element with a selected range, allow user to drag the selection handles.\n    if ('selectionStart' in target && 'selectionEnd' in target && target.selectionStart < target.selectionEnd && target.ownerDocument.activeElement === target) allowTouchMove = true;\n  };\n  // Prevent scrolling up when at the top and scrolling down when at the bottom\n  // of a nested scrollable area, otherwise mobile Safari will start scrolling\n  // the window instead.\n  // This must be applied before the touchstart event as of iOS 26, so inject it as a <style> element.\n  let style = document.createElement('style');\n  style.textContent = `\n@layer {\n  * {\n    overscroll-behavior: contain;\n  }\n}`.trim();\n  document.head.prepend(style);\n  let onTouchMove = e => {\n    // Allow pinch-zooming.\n    if (e.touches.length === 2 || allowTouchMove) return;\n    // Prevent scrolling the window.\n    if (!scrollable || scrollable === document.documentElement || scrollable === document.body) {\n      e.preventDefault();\n      return;\n    }\n    // overscroll-behavior should prevent scroll chaining, but currently does not\n    // if the element doesn't actually overflow. https://bugs.webkit.org/show_bug.cgi?id=243452\n    // This checks that both the width and height do not overflow, otherwise we might\n    // block horizontal scrolling too. In that case, adding `touch-action: pan-x` to\n    // the element will prevent vertical page scrolling. We can't add that automatically\n    // because it must be set before the touchstart event.\n    if (scrollable.scrollHeight === scrollable.clientHeight && scrollable.scrollWidth === scrollable.clientWidth) e.preventDefault();\n  };\n  let onBlur = e => {\n    let target = e.target;\n    let relatedTarget = e.relatedTarget;\n    if (relatedTarget && (0, $7mMvr$willOpenKeyboard)(relatedTarget)) {\n      // Focus without scrolling the whole page, and then scroll into view manually.\n      relatedTarget.focus({\n        preventScroll: true\n      });\n      $49c51c25361d4cd2$var$scrollIntoViewWhenReady(relatedTarget, (0, $7mMvr$willOpenKeyboard)(target));\n    } else if (!relatedTarget) {\n      var _target_parentElement;\n      // When tapping the Done button on the keyboard, focus moves to the body.\n      // FocusScope will then restore focus back to the input. Later when tapping\n      // the same input again, it is already focused, so no blur event will fire,\n      // resulting in the flow above never running and Safari's native scrolling occurring.\n      // Instead, move focus to the parent focusable element (e.g. the dialog).\n      let focusable = (_target_parentElement = target.parentElement) === null || _target_parentElement === void 0 ? void 0 : _target_parentElement.closest('[tabindex]');\n      focusable === null || focusable === void 0 ? void 0 : focusable.focus({\n        preventScroll: true\n      });\n    }\n  };\n  // Override programmatic focus to scroll into view without scrolling the whole page.\n  let focus = HTMLElement.prototype.focus;\n  HTMLElement.prototype.focus = function (opts) {\n    // Track whether the keyboard was already visible before.\n    let wasKeyboardVisible = document.activeElement != null && (0, $7mMvr$willOpenKeyboard)(document.activeElement);\n    // Focus the element without scrolling the page.\n    focus.call(this, {\n      ...opts,\n      preventScroll: true\n    });\n    if (!opts || !opts.preventScroll) $49c51c25361d4cd2$var$scrollIntoViewWhenReady(this, wasKeyboardVisible);\n  };\n  let removeEvents = (0, $7mMvr$chain)($49c51c25361d4cd2$var$addEvent(document, 'touchstart', onTouchStart, {\n    passive: false,\n    capture: true\n  }), $49c51c25361d4cd2$var$addEvent(document, 'touchmove', onTouchMove, {\n    passive: false,\n    capture: true\n  }), $49c51c25361d4cd2$var$addEvent(document, 'blur', onBlur, true));\n  return () => {\n    removeEvents();\n    style.remove();\n    HTMLElement.prototype.focus = focus;\n  };\n}\n// Sets a CSS property on an element, and returns a function to revert it to the previous value.\nfunction $49c51c25361d4cd2$var$setStyle(element, style, value) {\n  let cur = element.style[style];\n  element.style[style] = value;\n  return () => {\n    element.style[style] = cur;\n  };\n}\n// Adds an event listener to an element, and returns a function to remove it.\nfunction $49c51c25361d4cd2$var$addEvent(target, event, handler, options) {\n  // internal function, so it's ok to ignore the difficult to fix type error\n  // @ts-ignore\n  target.addEventListener(event, handler, options);\n  return () => {\n    // @ts-ignore\n    target.removeEventListener(event, handler, options);\n  };\n}\nfunction $49c51c25361d4cd2$var$scrollIntoViewWhenReady(target, wasKeyboardVisible) {\n  if (wasKeyboardVisible || !$49c51c25361d4cd2$var$visualViewport)\n    // If the keyboard was already visible, scroll the target into view immediately.\n    $49c51c25361d4cd2$var$scrollIntoView(target);else\n    // Otherwise, wait for the visual viewport to resize before scrolling so we can\n    // measure the correct position to scroll to.\n    $49c51c25361d4cd2$var$visualViewport.addEventListener('resize', () => $49c51c25361d4cd2$var$scrollIntoView(target), {\n      once: true\n    });\n}\nfunction $49c51c25361d4cd2$var$scrollIntoView(target) {\n  let root = document.scrollingElement || document.documentElement;\n  let nextTarget = target;\n  while (nextTarget && nextTarget !== root) {\n    // Find the parent scrollable element and adjust the scroll position if the target is not already in view.\n    let scrollable = (0, $7mMvr$getScrollParent)(nextTarget);\n    if (scrollable !== document.documentElement && scrollable !== document.body && scrollable !== nextTarget) {\n      let scrollableRect = scrollable.getBoundingClientRect();\n      let targetRect = nextTarget.getBoundingClientRect();\n      if (targetRect.top < scrollableRect.top || targetRect.bottom > scrollableRect.top + nextTarget.clientHeight) {\n        let bottom = scrollableRect.bottom;\n        if ($49c51c25361d4cd2$var$visualViewport) bottom = Math.min(bottom, $49c51c25361d4cd2$var$visualViewport.offsetTop + $49c51c25361d4cd2$var$visualViewport.height);\n        // Center within the viewport.\n        let adjustment = targetRect.top - scrollableRect.top - ((bottom - scrollableRect.top) / 2 - targetRect.height / 2);\n        scrollable.scrollTo({\n          // Clamp to the valid range to prevent over-scrolling.\n          top: Math.max(0, Math.min(scrollable.scrollHeight - scrollable.clientHeight, scrollable.scrollTop + adjustment)),\n          behavior: 'smooth'\n        });\n      }\n    }\n    nextTarget = scrollable.parentElement;\n  }\n}\nexport { $49c51c25361d4cd2$export$ee0f7cc6afcd1c18 as usePreventScroll };","map":{"version":3,"names":["$49c51c25361d4cd2$var$visualViewport","document","window","visualViewport","$49c51c25361d4cd2$var$preventScrollCount","$49c51c25361d4cd2$var$restore","$49c51c25361d4cd2$export$ee0f7cc6afcd1c18","options","isDisabled","$7mMvr$useLayoutEffect","$7mMvr$isIOS","$49c51c25361d4cd2$var$preventScrollMobileSafari","$49c51c25361d4cd2$var$preventScrollStandard","scrollbarWidth","innerWidth","documentElement","clientWidth","$7mMvr$chain","style","$49c51c25361d4cd2$var$setStyle","scrollable","allowTouchMove","onTouchStart","e","target","$7mMvr$isScrollable","$7mMvr$getScrollParent","selection","ownerDocument","defaultView","getSelection","isCollapsed","containsNode","selectionStart","selectionEnd","activeElement","createElement","textContent","trim","head","prepend","onTouchMove","touches","length","body","preventDefault","scrollHeight","clientHeight","scrollWidth","onBlur","relatedTarget","$7mMvr$willOpenKeyboard","focus","preventScroll","$49c51c25361d4cd2$var$scrollIntoViewWhenReady","_target_parentElement","focusable","parentElement","closest","HTMLElement","prototype","opts","wasKeyboardVisible","call","removeEvents","$49c51c25361d4cd2$var$addEvent","passive","capture","remove","element","value","cur","event","handler","addEventListener","removeEventListener","$49c51c25361d4cd2$var$scrollIntoView","once","root","scrollingElement","nextTarget","scrollableRect","getBoundingClientRect","targetRect","top","bottom","Math","min","offsetTop","height","adjustment","scrollTo","max","scrollTop","behavior"],"sources":["C:\\Users\\Aluno\\Documents\\GitHub\\--Arcano_Store--\\arcanostore\\node_modules\\@react-aria\\overlays\\dist\\packages\\@react-aria\\overlays\\src\\usePreventScroll.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {chain, getScrollParent, isIOS, isScrollable, useLayoutEffect, willOpenKeyboard} from '@react-aria/utils';\n\ninterface PreventScrollOptions {\n  /** Whether the scroll lock is disabled. */\n  isDisabled?: boolean\n}\n\nconst visualViewport = typeof document !== 'undefined' && window.visualViewport;\n\n// The number of active usePreventScroll calls. Used to determine whether to revert back to the original page style/scroll position\nlet preventScrollCount = 0;\nlet restore;\n\n/**\n * Prevents scrolling on the document body on mount, and\n * restores it on unmount. Also ensures that content does not\n * shift due to the scrollbars disappearing.\n */\nexport function usePreventScroll(options: PreventScrollOptions = {}): void {\n  let {isDisabled} = options;\n\n  useLayoutEffect(() => {\n    if (isDisabled) {\n      return;\n    }\n\n    preventScrollCount++;\n    if (preventScrollCount === 1) {\n      if (isIOS()) {\n        restore = preventScrollMobileSafari();\n      } else {\n        restore = preventScrollStandard();\n      }\n    }\n\n    return () => {\n      preventScrollCount--;\n      if (preventScrollCount === 0) {\n        restore();\n      }\n    };\n  }, [isDisabled]);\n}\n\n// For most browsers, all we need to do is set `overflow: hidden` on the root element, and\n// add some padding to prevent the page from shifting when the scrollbar is hidden.\nfunction preventScrollStandard() {\n  let scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;\n  return chain(\n    scrollbarWidth > 0 &&\n      // Use scrollbar-gutter when supported because it also works for fixed positioned elements.\n      ('scrollbarGutter' in document.documentElement.style\n        ? setStyle(document.documentElement, 'scrollbarGutter', 'stable')\n        : setStyle(document.documentElement, 'paddingRight', `${scrollbarWidth}px`)),\n    setStyle(document.documentElement, 'overflow', 'hidden')\n  );\n}\n\n// Mobile Safari is a whole different beast. Even with overflow: hidden,\n// it still scrolls the page in many situations:\n//\n// 1. When the bottom toolbar and address bar are collapsed, page scrolling is always allowed.\n// 2. When the keyboard is visible, the viewport does not resize. Instead, the keyboard covers part of\n//    it, so it becomes scrollable.\n// 3. When tapping on an input, the page always scrolls so that the input is centered in the visual viewport.\n//    This may cause even fixed position elements to scroll off the screen.\n// 4. When using the next/previous buttons in the keyboard to navigate between inputs, the whole page always\n//    scrolls, even if the input is inside a nested scrollable element that could be scrolled instead.\n//\n// In order to work around these cases, and prevent scrolling without jankiness, we do a few things:\n//\n// 1. Prevent default on `touchmove` events that are not in a scrollable element. This prevents touch scrolling\n//    on the window.\n// 2. Set `overscroll-behavior: contain` on nested scrollable regions so they do not scroll the page when at\n//    the top or bottom. Work around a bug where this does not work when the element does not actually overflow\n//    by preventing default in a `touchmove` event. This is best effort: we can't prevent default when pinch\n//    zooming or when an element contains text selection, which may allow scrolling in some cases.\n// 3. Prevent default on `touchend` events on input elements and handle focusing the element ourselves.\n// 4. When focus moves to an input, create an off screen input and focus that temporarily. This prevents \n//    Safari from scrolling the page. After a small delay, focus the real input and scroll it into view\n//    ourselves, without scrolling the whole page.\nfunction preventScrollMobileSafari() {\n  let scrollable: Element;\n  let allowTouchMove = false;\n  let onTouchStart = (e: TouchEvent) => {\n    // Store the nearest scrollable parent element from the element that the user touched.\n    let target = e.target as Element;\n    scrollable = isScrollable(target) ? target : getScrollParent(target, true);\n    allowTouchMove = false;\n    \n    // If the target is selected, don't preventDefault in touchmove to allow user to adjust selection.\n    let selection = target.ownerDocument.defaultView!.getSelection();\n    if (selection && !selection.isCollapsed && selection.containsNode(target, true)) {\n      allowTouchMove = true;\n    }\n\n    // If this is a focused input element with a selected range, allow user to drag the selection handles.\n    if (\n      'selectionStart' in target && \n      'selectionEnd' in target &&\n      (target.selectionStart as number) < (target.selectionEnd as number) &&\n      target.ownerDocument.activeElement === target\n    ) {\n      allowTouchMove = true;\n    }\n  };\n\n  // Prevent scrolling up when at the top and scrolling down when at the bottom\n  // of a nested scrollable area, otherwise mobile Safari will start scrolling\n  // the window instead.\n  // This must be applied before the touchstart event as of iOS 26, so inject it as a <style> element.\n  let style = document.createElement('style');\n  style.textContent = `\n@layer {\n  * {\n    overscroll-behavior: contain;\n  }\n}`.trim();\n  document.head.prepend(style);\n\n  let onTouchMove = (e: TouchEvent) => {\n    // Allow pinch-zooming.\n    if (e.touches.length === 2 || allowTouchMove) {\n      return;\n    }\n\n    // Prevent scrolling the window.\n    if (!scrollable || scrollable === document.documentElement || scrollable === document.body) {\n      e.preventDefault();\n      return;\n    }\n\n    // overscroll-behavior should prevent scroll chaining, but currently does not\n    // if the element doesn't actually overflow. https://bugs.webkit.org/show_bug.cgi?id=243452\n    // This checks that both the width and height do not overflow, otherwise we might\n    // block horizontal scrolling too. In that case, adding `touch-action: pan-x` to\n    // the element will prevent vertical page scrolling. We can't add that automatically\n    // because it must be set before the touchstart event.\n    if (scrollable.scrollHeight === scrollable.clientHeight && scrollable.scrollWidth === scrollable.clientWidth) {\n      e.preventDefault();\n    }\n  };\n\n  let onBlur = (e: FocusEvent) => {\n    let target = e.target as HTMLElement;\n    let relatedTarget = e.relatedTarget as HTMLElement | null;\n    if (relatedTarget && willOpenKeyboard(relatedTarget)) {\n      // Focus without scrolling the whole page, and then scroll into view manually.\n      relatedTarget.focus({preventScroll: true});\n      scrollIntoViewWhenReady(relatedTarget, willOpenKeyboard(target));\n    } else if (!relatedTarget) {\n      // When tapping the Done button on the keyboard, focus moves to the body.\n      // FocusScope will then restore focus back to the input. Later when tapping\n      // the same input again, it is already focused, so no blur event will fire,\n      // resulting in the flow above never running and Safari's native scrolling occurring.\n      // Instead, move focus to the parent focusable element (e.g. the dialog).\n      let focusable = target.parentElement?.closest('[tabindex]') as HTMLElement | null;\n      focusable?.focus({preventScroll: true});\n    }\n  };\n\n  // Override programmatic focus to scroll into view without scrolling the whole page.\n  let focus = HTMLElement.prototype.focus;\n  HTMLElement.prototype.focus = function (opts) {\n    // Track whether the keyboard was already visible before.\n    let wasKeyboardVisible = document.activeElement != null && willOpenKeyboard(document.activeElement);\n\n    // Focus the element without scrolling the page.\n    focus.call(this, {...opts, preventScroll: true});\n\n    if (!opts || !opts.preventScroll) {\n      scrollIntoViewWhenReady(this, wasKeyboardVisible);\n    }\n  };\n\n  let removeEvents = chain(\n    addEvent(document, 'touchstart', onTouchStart, {passive: false, capture: true}),\n    addEvent(document, 'touchmove', onTouchMove, {passive: false, capture: true}),\n    addEvent(document, 'blur', onBlur, true)\n  );\n\n  return () => {\n    removeEvents();\n    style.remove();\n    HTMLElement.prototype.focus = focus;\n  };\n}\n\n// Sets a CSS property on an element, and returns a function to revert it to the previous value.\nfunction setStyle(element: HTMLElement, style: string, value: string) {\n  let cur = element.style[style];\n  element.style[style] = value;\n\n  return () => {\n    element.style[style] = cur;\n  };\n}\n\n// Adds an event listener to an element, and returns a function to remove it.\nfunction addEvent<K extends keyof GlobalEventHandlersEventMap>(\n  target: Document | Window,\n  event: K,\n  handler: (this: Document | Window, ev: GlobalEventHandlersEventMap[K]) => any,\n  options?: boolean | AddEventListenerOptions\n) {\n  // internal function, so it's ok to ignore the difficult to fix type error\n  // @ts-ignore\n  target.addEventListener(event, handler, options);\n  return () => {\n    // @ts-ignore\n    target.removeEventListener(event, handler, options);\n  };\n}\n\nfunction scrollIntoViewWhenReady(target: Element, wasKeyboardVisible: boolean) {\n  if (wasKeyboardVisible || !visualViewport) {\n    // If the keyboard was already visible, scroll the target into view immediately.\n    scrollIntoView(target);\n  } else {\n    // Otherwise, wait for the visual viewport to resize before scrolling so we can\n    // measure the correct position to scroll to.\n    visualViewport.addEventListener('resize', () => scrollIntoView(target), {once: true});\n  }\n}\n\nfunction scrollIntoView(target: Element) {\n  let root = document.scrollingElement || document.documentElement;\n  let nextTarget: Element | null = target;\n  while (nextTarget && nextTarget !== root) {\n    // Find the parent scrollable element and adjust the scroll position if the target is not already in view.\n    let scrollable = getScrollParent(nextTarget);\n    if (scrollable !== document.documentElement && scrollable !== document.body && scrollable !== nextTarget) {\n      let scrollableRect = scrollable.getBoundingClientRect();\n      let targetRect = nextTarget.getBoundingClientRect();\n      if (targetRect.top < scrollableRect.top || targetRect.bottom > scrollableRect.top + nextTarget.clientHeight) {\n        let bottom = scrollableRect.bottom;\n        if (visualViewport) {\n          bottom = Math.min(bottom, visualViewport.offsetTop + visualViewport.height);\n        }\n\n        // Center within the viewport.\n        let adjustment = (targetRect.top - scrollableRect.top) - ((bottom - scrollableRect.top) / 2 - targetRect.height / 2);\n        scrollable.scrollTo({\n          // Clamp to the valid range to prevent over-scrolling.\n          top: Math.max(0, Math.min(scrollable.scrollHeight - scrollable.clientHeight, scrollable.scrollTop + adjustment)),\n          behavior: 'smooth'\n        });\n      }\n    }\n\n    nextTarget = scrollable.parentElement;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}