{"ast":null,"code":"\"use client\";\n\n// src/utils.ts\nimport { useContext, useMemo, useRef, useCallback } from \"react\";\nimport { mergeProps, mergeRefs } from \"@heroui/shared-utils\";\nvar DEFAULT_SLOT = Symbol(\"default\");\nfunction useObjectRef(ref) {\n  const objRef = useRef(null);\n  const cleanupRef = useRef(void 0);\n  const refEffect = useCallback(instance => {\n    if (typeof ref === \"function\") {\n      const refCallback = ref;\n      const refCleanup = refCallback(instance);\n      return () => {\n        if (typeof refCleanup === \"function\") {\n          refCleanup();\n        } else {\n          refCallback(null);\n        }\n      };\n    } else if (ref) {\n      ref.current = instance;\n      return () => {\n        ref.current = null;\n      };\n    }\n  }, [ref]);\n  return useMemo(() => ({\n    get current() {\n      return objRef.current;\n    },\n    set current(value) {\n      objRef.current = value;\n      if (cleanupRef.current) {\n        cleanupRef.current();\n        cleanupRef.current = void 0;\n      }\n      if (value != null) {\n        cleanupRef.current = refEffect(value);\n      }\n    }\n  }), [refEffect]);\n}\nfunction useSlottedContext(context, slot) {\n  let ctx = useContext(context);\n  if (slot === null) {\n    return null;\n  }\n  if (ctx && typeof ctx === \"object\" && \"slots\" in ctx && ctx.slots) {\n    let availableSlots = new Intl.ListFormat().format(Object.keys(ctx.slots).map(p => `\"${p}\"`));\n    if (!slot && !ctx.slots[DEFAULT_SLOT]) {\n      throw new Error(`A slot prop is required. Valid slot names are ${availableSlots}.`);\n    }\n    let slotKey = slot || DEFAULT_SLOT;\n    if (!ctx.slots[slotKey]) {\n      throw new Error(`Invalid slot \"${slot}\". Valid slot names are ${availableSlots}.`);\n    }\n    return ctx.slots[slotKey];\n  }\n  return ctx;\n}\nfunction useContextProps(props, ref, context) {\n  let ctx = useSlottedContext(context, props.slot) || {};\n  let {\n    ref: contextRef,\n    ...contextProps\n  } = ctx;\n  let mergedRef = useObjectRef(useMemo(() => mergeRefs(ref, contextRef), [ref, contextRef]));\n  let mergedProps = mergeProps(contextProps, props);\n  if (\"style\" in contextProps && contextProps.style && \"style\" in props && props.style) {\n    if (typeof contextProps.style === \"function\" || typeof props.style === \"function\") {\n      mergedProps.style = renderProps => {\n        let contextStyle = typeof contextProps.style === \"function\" ? contextProps.style(renderProps) : contextProps.style;\n        let defaultStyle = {\n          ...renderProps.defaultStyle,\n          ...contextStyle\n        };\n        let style = typeof props.style === \"function\" ? props.style({\n          ...renderProps,\n          defaultStyle\n        }) : props.style;\n        return {\n          ...defaultStyle,\n          ...style\n        };\n      };\n    } else {\n      mergedProps.style = {\n        ...contextProps.style,\n        ...props.style\n      };\n    }\n  }\n  return [mergedProps, mergedRef];\n}\nexport { DEFAULT_SLOT, useObjectRef, useSlottedContext, useContextProps };","map":{"version":3,"names":["useContext","useMemo","useRef","useCallback","mergeProps","mergeRefs","DEFAULT_SLOT","Symbol","useObjectRef","ref","objRef","cleanupRef","refEffect","instance","refCallback","refCleanup","current","value","useSlottedContext","context","slot","ctx","slots","availableSlots","Intl","ListFormat","format","Object","keys","map","p","Error","slotKey","useContextProps","props","contextRef","contextProps","mergedRef","mergedProps","style","renderProps","contextStyle","defaultStyle"],"sources":["C:/Users/Aluno/Documents/GitHub/--Arcano_Store--/arcanostore/node_modules/@heroui/form/dist/chunk-YMDFNRVV.mjs"],"sourcesContent":["\"use client\";\n\n// src/utils.ts\nimport { useContext, useMemo, useRef, useCallback } from \"react\";\nimport { mergeProps, mergeRefs } from \"@heroui/shared-utils\";\nvar DEFAULT_SLOT = Symbol(\"default\");\nfunction useObjectRef(ref) {\n  const objRef = useRef(null);\n  const cleanupRef = useRef(void 0);\n  const refEffect = useCallback(\n    (instance) => {\n      if (typeof ref === \"function\") {\n        const refCallback = ref;\n        const refCleanup = refCallback(instance);\n        return () => {\n          if (typeof refCleanup === \"function\") {\n            refCleanup();\n          } else {\n            refCallback(null);\n          }\n        };\n      } else if (ref) {\n        ref.current = instance;\n        return () => {\n          ref.current = null;\n        };\n      }\n    },\n    [ref]\n  );\n  return useMemo(\n    () => ({\n      get current() {\n        return objRef.current;\n      },\n      set current(value) {\n        objRef.current = value;\n        if (cleanupRef.current) {\n          cleanupRef.current();\n          cleanupRef.current = void 0;\n        }\n        if (value != null) {\n          cleanupRef.current = refEffect(value);\n        }\n      }\n    }),\n    [refEffect]\n  );\n}\nfunction useSlottedContext(context, slot) {\n  let ctx = useContext(context);\n  if (slot === null) {\n    return null;\n  }\n  if (ctx && typeof ctx === \"object\" && \"slots\" in ctx && ctx.slots) {\n    let availableSlots = new Intl.ListFormat().format(Object.keys(ctx.slots).map((p) => `\"${p}\"`));\n    if (!slot && !ctx.slots[DEFAULT_SLOT]) {\n      throw new Error(`A slot prop is required. Valid slot names are ${availableSlots}.`);\n    }\n    let slotKey = slot || DEFAULT_SLOT;\n    if (!ctx.slots[slotKey]) {\n      throw new Error(`Invalid slot \"${slot}\". Valid slot names are ${availableSlots}.`);\n    }\n    return ctx.slots[slotKey];\n  }\n  return ctx;\n}\nfunction useContextProps(props, ref, context) {\n  let ctx = useSlottedContext(context, props.slot) || {};\n  let { ref: contextRef, ...contextProps } = ctx;\n  let mergedRef = useObjectRef(useMemo(() => mergeRefs(ref, contextRef), [ref, contextRef]));\n  let mergedProps = mergeProps(contextProps, props);\n  if (\"style\" in contextProps && contextProps.style && \"style\" in props && props.style) {\n    if (typeof contextProps.style === \"function\" || typeof props.style === \"function\") {\n      mergedProps.style = (renderProps) => {\n        let contextStyle = typeof contextProps.style === \"function\" ? contextProps.style(renderProps) : contextProps.style;\n        let defaultStyle = { ...renderProps.defaultStyle, ...contextStyle };\n        let style = typeof props.style === \"function\" ? props.style({ ...renderProps, defaultStyle }) : props.style;\n        return { ...defaultStyle, ...style };\n      };\n    } else {\n      mergedProps.style = { ...contextProps.style, ...props.style };\n    }\n  }\n  return [mergedProps, mergedRef];\n}\n\nexport {\n  DEFAULT_SLOT,\n  useObjectRef,\n  useSlottedContext,\n  useContextProps\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}