{"ast":null,"code":"import { getFormatOptions as $35a22f14a1f04b11$export$7e319ea407e63bc0, getPlaceholderTime as $35a22f14a1f04b11$export$c5221a78ef73c5e9, getRangeValidationResult as $35a22f14a1f04b11$export$80ff8fc0ae339c13, useDefaultProps as $35a22f14a1f04b11$export$2440da353cedad43 } from \"./utils.mjs\";\nimport { toCalendarDate as $hac8C$toCalendarDate, toCalendarDateTime as $hac8C$toCalendarDateTime, DateFormatter as $hac8C$DateFormatter } from \"@internationalized/date\";\nimport { useFormValidationState as $hac8C$useFormValidationState } from \"@react-stately/form\";\nimport { useOverlayTriggerState as $hac8C$useOverlayTriggerState } from \"@react-stately/overlays\";\nimport { useControlledState as $hac8C$useControlledState } from \"@react-stately/utils\";\nimport { useState as $hac8C$useState, useMemo as $hac8C$useMemo } from \"react\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nfunction $93c38a5e28be6249$export$e50a61c1de9f574(props) {\n  var _value_start, _value_end;\n  let overlayState = (0, $hac8C$useOverlayTriggerState)(props);\n  let [controlledValue, setControlledValue] = (0, $hac8C$useControlledState)(props.value, props.defaultValue || null, props.onChange);\n  let [initialValue] = (0, $hac8C$useState)(controlledValue);\n  let [placeholderValue, setPlaceholderValue] = (0, $hac8C$useState)(() => controlledValue || {\n    start: null,\n    end: null\n  });\n  // Reset the placeholder if the value prop is set to null.\n  if (controlledValue == null && placeholderValue.start && placeholderValue.end) {\n    placeholderValue = {\n      start: null,\n      end: null\n    };\n    setPlaceholderValue(placeholderValue);\n  }\n  let value = controlledValue || placeholderValue;\n  let setValue = newValue => {\n    value = newValue || {\n      start: null,\n      end: null\n    };\n    setPlaceholderValue(value);\n    if ($93c38a5e28be6249$var$isCompleteRange(value)) setControlledValue(value);else setControlledValue(null);\n  };\n  let v = (value === null || value === void 0 ? void 0 : value.start) || (value === null || value === void 0 ? void 0 : value.end) || props.placeholderValue || null;\n  let [granularity, defaultTimeZone] = (0, $35a22f14a1f04b11$export$2440da353cedad43)(v, props.granularity);\n  let hasTime = granularity === 'hour' || granularity === 'minute' || granularity === 'second';\n  var _props_shouldCloseOnSelect;\n  let shouldCloseOnSelect = (_props_shouldCloseOnSelect = props.shouldCloseOnSelect) !== null && _props_shouldCloseOnSelect !== void 0 ? _props_shouldCloseOnSelect : true;\n  let [dateRange, setSelectedDateRange] = (0, $hac8C$useState)(null);\n  let [timeRange, setSelectedTimeRange] = (0, $hac8C$useState)(null);\n  if (value && $93c38a5e28be6249$var$isCompleteRange(value)) {\n    dateRange = value;\n    if ('hour' in value.start) timeRange = value;\n  }\n  let commitValue = (dateRange, timeRange) => {\n    setValue({\n      start: 'timeZone' in timeRange.start ? timeRange.start.set((0, $hac8C$toCalendarDate)(dateRange.start)) : (0, $hac8C$toCalendarDateTime)(dateRange.start, timeRange.start),\n      end: 'timeZone' in timeRange.end ? timeRange.end.set((0, $hac8C$toCalendarDate)(dateRange.end)) : (0, $hac8C$toCalendarDateTime)(dateRange.end, timeRange.end)\n    });\n    setSelectedDateRange(null);\n    setSelectedTimeRange(null);\n    validation.commitValidation();\n  };\n  // Intercept setValue to make sure the Time section is not changed by date selection in Calendar\n  let setDateRange = range => {\n    let shouldClose = typeof shouldCloseOnSelect === 'function' ? shouldCloseOnSelect() : shouldCloseOnSelect;\n    if (hasTime) {\n      // Set a placeholder time if the popover is closing so we don't leave the field in an incomplete state.\n      if ($93c38a5e28be6249$var$isCompleteRange(range) && (shouldClose || (timeRange === null || timeRange === void 0 ? void 0 : timeRange.start) && (timeRange === null || timeRange === void 0 ? void 0 : timeRange.end))) commitValue(range, {\n        start: (timeRange === null || timeRange === void 0 ? void 0 : timeRange.start) || (0, $35a22f14a1f04b11$export$c5221a78ef73c5e9)(props.placeholderValue),\n        end: (timeRange === null || timeRange === void 0 ? void 0 : timeRange.end) || (0, $35a22f14a1f04b11$export$c5221a78ef73c5e9)(props.placeholderValue)\n      });else setSelectedDateRange(range);\n    } else if ($93c38a5e28be6249$var$isCompleteRange(range)) {\n      setValue(range);\n      validation.commitValidation();\n    } else setSelectedDateRange(range);\n    if (shouldClose) overlayState.setOpen(false);\n  };\n  let setTimeRange = range => {\n    if ($93c38a5e28be6249$var$isCompleteRange(dateRange) && $93c38a5e28be6249$var$isCompleteRange(range)) commitValue(dateRange, range);else setSelectedTimeRange(range);\n  };\n  let showEra = (value === null || value === void 0 ? void 0 : (_value_start = value.start) === null || _value_start === void 0 ? void 0 : _value_start.calendar.identifier) === 'gregory' && value.start.era === 'BC' || (value === null || value === void 0 ? void 0 : (_value_end = value.end) === null || _value_end === void 0 ? void 0 : _value_end.calendar.identifier) === 'gregory' && value.end.era === 'BC';\n  let formatOpts = (0, $hac8C$useMemo)(() => ({\n    granularity: granularity,\n    timeZone: defaultTimeZone,\n    hideTimeZone: props.hideTimeZone,\n    hourCycle: props.hourCycle,\n    shouldForceLeadingZeros: props.shouldForceLeadingZeros,\n    showEra: showEra\n  }), [granularity, props.hourCycle, props.shouldForceLeadingZeros, defaultTimeZone, props.hideTimeZone, showEra]);\n  let {\n    minValue: minValue,\n    maxValue: maxValue,\n    isDateUnavailable: isDateUnavailable\n  } = props;\n  let builtinValidation = (0, $hac8C$useMemo)(() => (0, $35a22f14a1f04b11$export$80ff8fc0ae339c13)(value, minValue, maxValue, isDateUnavailable, formatOpts), [value, minValue, maxValue, isDateUnavailable, formatOpts]);\n  let validation = (0, $hac8C$useFormValidationState)({\n    ...props,\n    value: controlledValue,\n    name: (0, $hac8C$useMemo)(() => [props.startName, props.endName].filter(n => n != null), [props.startName, props.endName]),\n    builtinValidation: builtinValidation\n  });\n  let isValueInvalid = validation.displayValidation.isInvalid;\n  let validationState = props.validationState || (isValueInvalid ? 'invalid' : null);\n  var _props_defaultValue;\n  return {\n    ...validation,\n    value: value,\n    defaultValue: (_props_defaultValue = props.defaultValue) !== null && _props_defaultValue !== void 0 ? _props_defaultValue : initialValue,\n    setValue: setValue,\n    dateRange: dateRange,\n    timeRange: timeRange,\n    granularity: granularity,\n    hasTime: hasTime,\n    setDate(part, date) {\n      var _dateRange_end, _dateRange_start;\n      if (part === 'start') setDateRange({\n        start: date,\n        end: (_dateRange_end = dateRange === null || dateRange === void 0 ? void 0 : dateRange.end) !== null && _dateRange_end !== void 0 ? _dateRange_end : null\n      });else setDateRange({\n        start: (_dateRange_start = dateRange === null || dateRange === void 0 ? void 0 : dateRange.start) !== null && _dateRange_start !== void 0 ? _dateRange_start : null,\n        end: date\n      });\n    },\n    setTime(part, time) {\n      var _timeRange_end, _timeRange_start;\n      if (part === 'start') setTimeRange({\n        start: time,\n        end: (_timeRange_end = timeRange === null || timeRange === void 0 ? void 0 : timeRange.end) !== null && _timeRange_end !== void 0 ? _timeRange_end : null\n      });else setTimeRange({\n        start: (_timeRange_start = timeRange === null || timeRange === void 0 ? void 0 : timeRange.start) !== null && _timeRange_start !== void 0 ? _timeRange_start : null,\n        end: time\n      });\n    },\n    setDateTime(part, dateTime) {\n      var _value_end, _value_start;\n      if (part === 'start') setValue({\n        start: dateTime,\n        end: (_value_end = value === null || value === void 0 ? void 0 : value.end) !== null && _value_end !== void 0 ? _value_end : null\n      });else setValue({\n        start: (_value_start = value === null || value === void 0 ? void 0 : value.start) !== null && _value_start !== void 0 ? _value_start : null,\n        end: dateTime\n      });\n    },\n    setDateRange: setDateRange,\n    setTimeRange: setTimeRange,\n    ...overlayState,\n    setOpen(isOpen) {\n      // Commit the selected date range when the calendar is closed. Use a placeholder time if one wasn't set.\n      // If only the time range was set and not the date range, don't commit. The state will be preserved until\n      // the user opens the popover again.\n      if (!isOpen && !((value === null || value === void 0 ? void 0 : value.start) && (value === null || value === void 0 ? void 0 : value.end)) && $93c38a5e28be6249$var$isCompleteRange(dateRange) && hasTime) commitValue(dateRange, {\n        start: (timeRange === null || timeRange === void 0 ? void 0 : timeRange.start) || (0, $35a22f14a1f04b11$export$c5221a78ef73c5e9)(props.placeholderValue),\n        end: (timeRange === null || timeRange === void 0 ? void 0 : timeRange.end) || (0, $35a22f14a1f04b11$export$c5221a78ef73c5e9)(props.placeholderValue)\n      });\n      overlayState.setOpen(isOpen);\n    },\n    validationState: validationState,\n    isInvalid: isValueInvalid,\n    formatValue(locale, fieldOptions) {\n      if (!value || !value.start || !value.end) return null;\n      let startTimeZone = 'timeZone' in value.start ? value.start.timeZone : undefined;\n      let startGranularity = props.granularity || (value.start && 'minute' in value.start ? 'minute' : 'day');\n      let endTimeZone = 'timeZone' in value.end ? value.end.timeZone : undefined;\n      let endGranularity = props.granularity || (value.end && 'minute' in value.end ? 'minute' : 'day');\n      let startOptions = (0, $35a22f14a1f04b11$export$7e319ea407e63bc0)(fieldOptions, {\n        granularity: startGranularity,\n        timeZone: startTimeZone,\n        hideTimeZone: props.hideTimeZone,\n        hourCycle: props.hourCycle,\n        showEra: value.start.calendar.identifier === 'gregory' && value.start.era === 'BC' || value.end.calendar.identifier === 'gregory' && value.end.era === 'BC'\n      });\n      let startDate = value.start.toDate(startTimeZone || 'UTC');\n      let endDate = value.end.toDate(endTimeZone || 'UTC');\n      let startFormatter = new (0, $hac8C$DateFormatter)(locale, startOptions);\n      let endFormatter;\n      if (startTimeZone === endTimeZone && startGranularity === endGranularity && value.start.compare(value.end) !== 0) {\n        // Use formatRange, as it results in shorter output when some of the fields\n        // are shared between the start and end dates (e.g. the same month).\n        // Formatting will fail if the end date is before the start date. Fall back below when that happens.\n        try {\n          let parts = startFormatter.formatRangeToParts(startDate, endDate);\n          // Find the separator between the start and end date. This is determined\n          // by finding the last shared literal before the end range.\n          let separatorIndex = -1;\n          for (let i = 0; i < parts.length; i++) {\n            let part = parts[i];\n            if (part.source === 'shared' && part.type === 'literal') separatorIndex = i;else if (part.source === 'endRange') break;\n          }\n          // Now we can combine the parts into start and end strings.\n          let start = '';\n          let end = '';\n          for (let i = 0; i < parts.length; i++) {\n            if (i < separatorIndex) start += parts[i].value;else if (i > separatorIndex) end += parts[i].value;\n          }\n          return {\n            start: start,\n            end: end\n          };\n        } catch {\n          // ignore\n        }\n        endFormatter = startFormatter;\n      } else {\n        let endOptions = (0, $35a22f14a1f04b11$export$7e319ea407e63bc0)(fieldOptions, {\n          granularity: endGranularity,\n          timeZone: endTimeZone,\n          hideTimeZone: props.hideTimeZone,\n          hourCycle: props.hourCycle\n        });\n        endFormatter = new (0, $hac8C$DateFormatter)(locale, endOptions);\n      }\n      return {\n        start: startFormatter.format(startDate),\n        end: endFormatter.format(endDate)\n      };\n    },\n    getDateFormatter(locale, formatOptions) {\n      let newOptions = {\n        ...formatOpts,\n        ...formatOptions\n      };\n      let newFormatOptions = (0, $35a22f14a1f04b11$export$7e319ea407e63bc0)({}, newOptions);\n      return new (0, $hac8C$DateFormatter)(locale, newFormatOptions);\n    }\n  };\n}\nfunction $93c38a5e28be6249$var$isCompleteRange(value) {\n  return (value === null || value === void 0 ? void 0 : value.start) != null && value.end != null;\n}\nexport { $93c38a5e28be6249$export$e50a61c1de9f574 as useDateRangePickerState };","map":{"version":3,"names":["$93c38a5e28be6249$export$e50a61c1de9f574","props","_value_start","_value_end","overlayState","$hac8C$useOverlayTriggerState","controlledValue","setControlledValue","$hac8C$useControlledState","value","defaultValue","onChange","initialValue","$hac8C$useState","placeholderValue","setPlaceholderValue","start","end","setValue","newValue","$93c38a5e28be6249$var$isCompleteRange","v","granularity","defaultTimeZone","$35a22f14a1f04b11$export$2440da353cedad43","hasTime","_props_shouldCloseOnSelect","shouldCloseOnSelect","dateRange","setSelectedDateRange","timeRange","setSelectedTimeRange","commitValue","set","$hac8C$toCalendarDate","$hac8C$toCalendarDateTime","validation","commitValidation","setDateRange","range","shouldClose","$35a22f14a1f04b11$export$c5221a78ef73c5e9","setOpen","setTimeRange","showEra","calendar","identifier","era","formatOpts","$hac8C$useMemo","timeZone","hideTimeZone","hourCycle","shouldForceLeadingZeros","minValue","maxValue","isDateUnavailable","builtinValidation","$35a22f14a1f04b11$export$80ff8fc0ae339c13","$hac8C$useFormValidationState","name","startName","endName","filter","n","isValueInvalid","displayValidation","isInvalid","validationState","_props_defaultValue","setDate","part","date","_dateRange_end","_dateRange_start","setTime","time","_timeRange_end","_timeRange_start","setDateTime","dateTime","isOpen","formatValue","locale","fieldOptions","startTimeZone","undefined","startGranularity","endTimeZone","endGranularity","startOptions","$35a22f14a1f04b11$export$7e319ea407e63bc0","startDate","toDate","endDate","startFormatter","$hac8C$DateFormatter","endFormatter","compare","parts","formatRangeToParts","separatorIndex","i","length","source","type","endOptions","format","getDateFormatter","formatOptions","newOptions","newFormatOptions"],"sources":["C:\\Users\\Aluno\\Documents\\GitHub\\--Arcano_Store--\\arcanostore\\node_modules\\@react-stately\\datepicker\\dist\\packages\\@react-stately\\datepicker\\src\\useDateRangePickerState.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\n\nimport {DateFormatter, toCalendarDate, toCalendarDateTime} from '@internationalized/date';\nimport {DateRange, DateRangePickerProps, DateValue, Granularity, MappedDateValue, TimeValue} from '@react-types/datepicker';\nimport {FieldOptions, FormatterOptions, getFormatOptions, getPlaceholderTime, getRangeValidationResult, useDefaultProps} from './utils';\nimport {FormValidationState, useFormValidationState} from '@react-stately/form';\nimport {OverlayTriggerState, useOverlayTriggerState} from '@react-stately/overlays';\nimport {RangeValue, ValidationState} from '@react-types/shared';\nimport {useControlledState} from '@react-stately/utils';\nimport {useMemo, useState} from 'react';\n\nexport interface DateRangePickerStateOptions<T extends DateValue = DateValue> extends DateRangePickerProps<T> {\n  /**\n   * Determines whether the date picker popover should close automatically when a date is selected.\n   * @default true\n   */\n  shouldCloseOnSelect?: boolean | (() => boolean)\n}\n\ntype TimeRange = RangeValue<TimeValue>;\nexport interface DateRangePickerState extends OverlayTriggerState, FormValidationState {\n  /** The currently selected date range. */\n  value: RangeValue<DateValue | null>,\n  /** The default selected date range. */\n  defaultValue: DateRange | null,\n  /** Sets the selected date range. */\n  setValue(value: DateRange | null): void,\n  /**\n   * The date portion of the selected range. This may be set prior to `value` if the user has\n   * selected a date range but has not yet selected a time range.\n   */\n  dateRange: RangeValue<DateValue | null> | null,\n  /** Sets the date portion of the selected range. */\n  setDateRange(value: DateRange): void,\n  /**\n   * The time portion of the selected range. This may be set prior to `value` if the user has\n   * selected a time range but has not yet selected a date range.\n   */\n  timeRange: RangeValue<TimeValue | null> | null,\n  /** Sets the time portion of the selected range. */\n  setTimeRange(value: TimeRange): void,\n  /** Sets the date portion of either the start or end of the selected range. */\n  setDate(part: 'start' | 'end', value: DateValue | null): void,\n  /** Sets the time portion of either the start or end of the selected range. */\n  setTime(part: 'start' | 'end', value: TimeValue | null): void,\n  /** Sets the date and time of either the start or end of the selected range. */\n  setDateTime(part: 'start' | 'end', value: DateValue | null): void,\n  /** The granularity for the field, based on the `granularity` prop and current value. */\n  granularity: Granularity,\n  /** Whether the date range picker supports selecting times, according to the `granularity` prop and current value. */\n  hasTime: boolean,\n  /** Whether the calendar popover is currently open. */\n  isOpen: boolean,\n  /** Sets whether the calendar popover is open. */\n  setOpen(isOpen: boolean): void,\n  /**\n   * The current validation state of the date range picker, based on the `validationState`, `minValue`, and `maxValue` props.\n   * @deprecated Use `isInvalid` instead.\n   */\n  validationState: ValidationState | null,\n  /** Whether the date range picker is invalid, based on the `isInvalid`, `minValue`, and `maxValue` props. */\n  isInvalid: boolean,\n  /** Formats the selected range using the given options. */\n  formatValue(locale: string, fieldOptions: FieldOptions): {start: string, end: string} | null,\n  /** Gets a formatter based on state's props. */\n  getDateFormatter(locale: string, formatOptions: FormatterOptions): DateFormatter\n}\n\n/**\n * Provides state management for a date range picker component.\n * A date range picker combines two DateFields and a RangeCalendar popover to allow\n * users to enter or select a date and time range.\n */\nexport function useDateRangePickerState<T extends DateValue = DateValue>(props: DateRangePickerStateOptions<T>): DateRangePickerState {\n  let overlayState = useOverlayTriggerState(props);\n  let [controlledValue, setControlledValue] = useControlledState<DateRange | null, RangeValue<MappedDateValue<T>> | null>(props.value, props.defaultValue || null, props.onChange);\n  let [initialValue] = useState(controlledValue);\n  let [placeholderValue, setPlaceholderValue] = useState<RangeValue<DateValue | null>>(() => controlledValue || {start: null, end: null});\n\n  // Reset the placeholder if the value prop is set to null.\n  if (controlledValue == null && placeholderValue.start && placeholderValue.end) {\n    placeholderValue = {start: null, end: null};\n    setPlaceholderValue(placeholderValue);\n  }\n\n  let value = controlledValue || placeholderValue;\n\n  let setValue = (newValue: RangeValue<DateValue | null> | null) => {\n    value = newValue || {start: null, end: null};\n    setPlaceholderValue(value);\n    if (isCompleteRange(value)) {\n      setControlledValue(value);\n    } else {\n      setControlledValue(null);\n    }\n  };\n\n  let v = (value?.start || value?.end || props.placeholderValue || null);\n  let [granularity, defaultTimeZone] = useDefaultProps(v, props.granularity);\n  let hasTime = granularity === 'hour' || granularity === 'minute' || granularity === 'second';\n  let shouldCloseOnSelect = props.shouldCloseOnSelect ?? true;\n\n  let [dateRange, setSelectedDateRange] = useState<RangeValue<DateValue | null> | null>(null);\n  let [timeRange, setSelectedTimeRange] = useState<RangeValue<TimeValue | null> | null>(null);\n\n  if (value && isCompleteRange(value)) {\n    dateRange = value;\n    if ('hour' in value.start) {\n      timeRange = value as TimeRange;\n    }\n  }\n\n  let commitValue = (dateRange: DateRange, timeRange: TimeRange) => {\n    setValue({\n      start: 'timeZone' in timeRange.start ? timeRange.start.set(toCalendarDate(dateRange.start)) : toCalendarDateTime(dateRange.start, timeRange.start),\n      end: 'timeZone' in timeRange.end ? timeRange.end.set(toCalendarDate(dateRange.end)) : toCalendarDateTime(dateRange.end, timeRange.end)\n    });\n    setSelectedDateRange(null);\n    setSelectedTimeRange(null);\n    validation.commitValidation();\n  };\n\n  // Intercept setValue to make sure the Time section is not changed by date selection in Calendar\n  let setDateRange = (range: RangeValue<DateValue | null>) => {\n    let shouldClose = typeof shouldCloseOnSelect === 'function' ? shouldCloseOnSelect() : shouldCloseOnSelect;\n    if (hasTime) {\n      // Set a placeholder time if the popover is closing so we don't leave the field in an incomplete state.\n      if (isCompleteRange(range) && (shouldClose || (timeRange?.start && timeRange?.end))) {\n        commitValue(range, {\n          start: timeRange?.start || getPlaceholderTime(props.placeholderValue),\n          end: timeRange?.end || getPlaceholderTime(props.placeholderValue)\n        });\n      } else {\n        setSelectedDateRange(range);\n      }\n    } else if (isCompleteRange(range)) {\n      setValue(range);\n      validation.commitValidation();\n    } else {\n      setSelectedDateRange(range);\n    }\n\n    if (shouldClose) {\n      overlayState.setOpen(false);\n    }\n  };\n\n  let setTimeRange = (range: RangeValue<TimeValue | null>) => {\n    if (isCompleteRange(dateRange) && isCompleteRange(range)) {\n      commitValue(dateRange, range);\n    } else {\n      setSelectedTimeRange(range);\n    }\n  };\n\n  let showEra = (value?.start?.calendar.identifier === 'gregory' && value.start.era === 'BC') || (value?.end?.calendar.identifier === 'gregory' && value.end.era === 'BC');\n  let formatOpts = useMemo(() => ({\n    granularity,\n    timeZone: defaultTimeZone,\n    hideTimeZone: props.hideTimeZone,\n    hourCycle: props.hourCycle,\n    shouldForceLeadingZeros: props.shouldForceLeadingZeros,\n    showEra\n  }), [granularity, props.hourCycle, props.shouldForceLeadingZeros, defaultTimeZone, props.hideTimeZone, showEra]);\n\n  let {minValue, maxValue, isDateUnavailable} = props;\n  let builtinValidation = useMemo(() => getRangeValidationResult(\n    value,\n    minValue,\n    maxValue,\n    isDateUnavailable,\n    formatOpts\n  ), [value, minValue, maxValue, isDateUnavailable, formatOpts]);\n\n  let validation = useFormValidationState({\n    ...props,\n    value: controlledValue as RangeValue<MappedDateValue<T>> | null,\n    name: useMemo(() => [props.startName, props.endName].filter(n => n != null), [props.startName, props.endName]),\n    builtinValidation\n  });\n\n  let isValueInvalid = validation.displayValidation.isInvalid;\n  let validationState: ValidationState | null = props.validationState || (isValueInvalid ? 'invalid' : null);\n\n  return {\n    ...validation,\n    value,\n    defaultValue: props.defaultValue ?? initialValue,\n    setValue,\n    dateRange,\n    timeRange,\n    granularity,\n    hasTime,\n    setDate(part, date) {\n      if (part === 'start') {\n        setDateRange({start: date, end: dateRange?.end ?? null});\n      } else {\n        setDateRange({start: dateRange?.start ?? null, end: date});\n      }\n    },\n    setTime(part, time) {\n      if (part === 'start') {\n        setTimeRange({start: time, end: timeRange?.end ?? null});\n      } else {\n        setTimeRange({start: timeRange?.start ?? null, end: time});\n      }\n    },\n    setDateTime(part, dateTime) {\n      if (part === 'start') {\n        setValue({start: dateTime, end: value?.end ?? null});\n      } else {\n        setValue({start: value?.start ?? null, end: dateTime});\n      }\n    },\n    setDateRange,\n    setTimeRange,\n    ...overlayState,\n    setOpen(isOpen) {\n      // Commit the selected date range when the calendar is closed. Use a placeholder time if one wasn't set.\n      // If only the time range was set and not the date range, don't commit. The state will be preserved until\n      // the user opens the popover again.\n      if (!isOpen && !(value?.start && value?.end) && isCompleteRange(dateRange) && hasTime) {\n        commitValue(dateRange, {\n          start: timeRange?.start || getPlaceholderTime(props.placeholderValue),\n          end: timeRange?.end || getPlaceholderTime(props.placeholderValue)\n        });\n      }\n\n      overlayState.setOpen(isOpen);\n    },\n    validationState,\n    isInvalid: isValueInvalid,\n    formatValue(locale, fieldOptions) {\n      if (!value || !value.start || !value.end) {\n        return null;\n      }\n\n      let startTimeZone = 'timeZone' in value.start ? value.start.timeZone : undefined;\n      let startGranularity = props.granularity || (value.start && 'minute' in value.start ? 'minute' : 'day');\n      let endTimeZone = 'timeZone' in value.end ? value.end.timeZone : undefined;\n      let endGranularity = props.granularity || (value.end && 'minute' in value.end ? 'minute' : 'day');\n\n      let startOptions = getFormatOptions(fieldOptions, {\n        granularity: startGranularity,\n        timeZone: startTimeZone,\n        hideTimeZone: props.hideTimeZone,\n        hourCycle: props.hourCycle,\n        showEra: (value.start.calendar.identifier === 'gregory' && value.start.era === 'BC') ||\n          (value.end.calendar.identifier === 'gregory' && value.end.era === 'BC')\n      });\n\n      let startDate = value.start.toDate(startTimeZone || 'UTC');\n      let endDate = value.end.toDate(endTimeZone || 'UTC');\n\n      let startFormatter = new DateFormatter(locale, startOptions);\n      let endFormatter: Intl.DateTimeFormat;\n      if (startTimeZone === endTimeZone && startGranularity === endGranularity && value.start.compare(value.end) !== 0) {\n        // Use formatRange, as it results in shorter output when some of the fields\n        // are shared between the start and end dates (e.g. the same month).\n        // Formatting will fail if the end date is before the start date. Fall back below when that happens.\n        try {\n          let parts = startFormatter.formatRangeToParts(startDate, endDate);\n\n          // Find the separator between the start and end date. This is determined\n          // by finding the last shared literal before the end range.\n          let separatorIndex = -1;\n          for (let i = 0; i < parts.length; i++) {\n            let part = parts[i];\n            if (part.source === 'shared' && part.type === 'literal') {\n              separatorIndex = i;\n            } else if (part.source === 'endRange') {\n              break;\n            }\n          }\n\n          // Now we can combine the parts into start and end strings.\n          let start = '';\n          let end = '';\n          for (let i = 0; i < parts.length; i++) {\n            if (i < separatorIndex) {\n              start += parts[i].value;\n            } else if (i > separatorIndex) {\n              end += parts[i].value;\n            }\n          }\n\n          return {start, end};\n        } catch {\n          // ignore\n        }\n\n        endFormatter = startFormatter;\n      } else {\n        let endOptions = getFormatOptions(fieldOptions, {\n          granularity: endGranularity,\n          timeZone: endTimeZone,\n          hideTimeZone: props.hideTimeZone,\n          hourCycle: props.hourCycle\n        });\n\n        endFormatter = new DateFormatter(locale, endOptions);\n      }\n\n      return {\n        start: startFormatter.format(startDate),\n        end: endFormatter.format(endDate)\n      };\n    },\n    getDateFormatter(locale, formatOptions: FormatterOptions) {\n      let newOptions = {...formatOpts, ...formatOptions};\n      let newFormatOptions = getFormatOptions({}, newOptions);\n      return new DateFormatter(locale, newFormatOptions);\n    }\n  };\n}\n\nfunction isCompleteRange<T>(value: RangeValue<T | null> | null): value is RangeValue<T> {\n  return value?.start != null && value.end != null;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}